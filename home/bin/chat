#!/bin/sh

NEWL='
'

default_u=localhost:11434; default_s='Respond concisely. Do not overuse tables. /no_think /nothink'
flag_c=; flag_e=; flag_h=; flag_l=; flag_n=
opt_m=; opt_s=$default_s; opt_u=$default_u
prompt=''
# shellcheck disable=SC2016
# Duplicate : to escape it
#tools='get_time:get current time:timezone=time zone:format=format (you can use %Y %m %d %H %M %S):TZ=$timezone date +"$format"
#list_files:list files in dir:dir=directory (use . for current dir):recursive=if nonempty, list files recusively:ls "${recursive::+-R}" "$dir"
#cat_file:show contents of a file:path=path to the file:cat "$path"'
toolsDefault='shell:run shell command (allowed commands:: date ls find cat grep head tail):cmd=command to run:if echo " date ls find cat grep head tail "|grep -q " ${cmd%% *} ";then sh -c "$cmd";else echo forbidden command;fi'
tools=
# TODO require tool confirm (e.g. by prefix its name with !)

while [ $# -ge 1 ]; do
    case "$1" in
        (-[!-][!-]*)  _1=${1#?} ; shift ; set -- "-${_1%"${_1#?}"}" "-${_1#?}" "$@" ;;
        (-c|--continue) flag_c=1  ; shift ;;
        (-e|--erase)    flag_e=1  ; shift ;;
        (-h|--help)     flag_h=1  ; shift ;;
        (-l|--list)     flag_l=1  ; shift ;;
        (-n|--noout)    flag_n=1  ; shift ;;
        (-m|--model)    opt_m="$2"; shift 2 ;;
        (-s|--system)   opt_s="$2"; shift 2 ;;
        (-u|--url)      opt_u="$2"; shift 2 ;;
        (-t|--tool)     [ "$2" = default ] && tools="$tools$NEWL$toolsDefault" || tools="$tools$NEWL$2"; shift 2 ;;
        (*) prompt="$*" ; break ;;
    esac
done

# echo "flag_e=[$flag_e] flag_h=[$flag_h] flag_l=[$flag_l] flag_n=[$flag_n] opt_m=[$opt_m] opt_u=[$opt_u] opt_s=[$opt_s] prompt=[$prompt]"; exit

help(){
    echo "Usage: $0 [options ...] [prompt ...]"
    echo "       cmd | $0 [options ...]"
    echo
    echo "Options:"
    echo "  -c, --continue         Continue upon previous tool calling"
    echo "  -e, --erase            Erase history before starting"
    echo "  -h, --help             Help"
    echo "  -l, --list             List models"
    echo "  -m, --model <model>    Model         (default: auto)"
    echo "  -n, --noout            No chat output file (still creates history)"
    echo "  -s, --system <prompt>  System prompt (default: $default_s)"
    echo "  -t, --tool <spec>      Define additional tools (\"default\" will enable default tools)"
    echo "  -u, --url <url>        URL of server (default: $default_u)"
    echo
    echo "Tool spec example:"
    echo "$toolsDefault"
}

error(){
    echo "Error: $*" >&2; exit 1
}


## Various checks

missing=
for i in curl jq stdbuf; do
    if ! command -v "$i" >/dev/null; then
        missing="$missing $i"
    fi
done
[ "$missing" ] && error "command not available:$missing"

[ "$flag_h" ] && { help; exit 0; }

res=$(curl -fs "$opt_u"/v1/models 2>/dev/null)
_sta=$?
[ "$_sta" -ne 0 ] && error "getting model list: server error"

models=$(echo "$res" | jq -r '.data[].id' 2>/dev/null) # do not care newlines
_sta=$?
[ "$_sta" -ne 0 ] && error "getting model list: format error"

[ ! "$opt_m" ] && opt_m=$(echo "$models" | head -n1)

[ "$flag_l" ] && { echo "$models"; exit 0; }

echo "$models" | grep -qFx "$opt_m" || error "model \"$opt_m\" is not available"


## Tools

tools_api=$(echo "$tools" | jq -R 'select(length>0)|[sub("::";"=x=x=";"g")|split(":")[]|sub("=x=x=";":";"g")]|{type:"function",function:{name:.[0],description:.[1],parameters:.[2:-1]|{type:"object",required:[.[]|split("=")[0]],properties:[.[]|split("=")|{key:.[0],value:{type:"string",description:.[1]}}]|from_entries}}}' | jq -s .)
tools_int=$(echo "$tools" | jq -R 'select(length>0)|[sub("::";"=x=x=";"g")|split(":")[]|sub("=x=x=";":";"g")]|{key:.[0],value:{flags:"",cmd:.[-1]}}' | jq -s 'from_entries')

# printf "tools_api=%s\ntools_int=%s\n" "$tools_api" "$tools_int" >&2; exit

# tools="[{
#    \"type\": \"function\",
#    \"function\": {
#        \"name\": \"get_time\",
#        \"description\": \"Get current time\",
#        \"parameters\": {
#            \"type\": \"object\",
#            \"properties\": {
#                \"timezone\": { \"type\": \"string\", \"description\": \"timezone\" }
#            },
#            \"required\": [\"timezone\"]
#        }
#    }
# }]"


## Build query

histfile=${TMPDIR:-/tmp}/chat-hist
[ "$flag_e" ] && rm -f "$histfile"
touch "$histfile"

if [ ! "$flag_c" ]; then
    if [ -t 0 ]; then printf %s "$prompt"; else cat; fi \
        | jq -Rs '{role:"user",content:.}' \
        >> "$histfile"
fi

outdir=$HOME/.cache/chat/
mkdir -p "$outdir"
outfile="$outdir"/chat-"$(date +%Y%m%d-%H%M%S)".txt
[ "$flag_n" ] && outfile=${TMPDIR:-/tmp}/chat-out
{
    jq -r 'if .content then "<\(.role)>\n\(.content)\n" else empty end' "$histfile"
    printf "<assistant>\n"
} > "$outfile"

cleanup(){ [ ! "$flag_n" ] || rm -f "$outfile"; }
trap cleanup INT TERM


## Main API call

# note: avoid including arbitrarily large strings in command parameter (use pipe instead)

# shellcheck disable=SC2016
jq -s --arg m "$opt_m" --arg s "$opt_s" --argjson t "$tools_api" \
    '{model:$m,stream:true,tools:$t,messages:[{role:"system",content:$s},.[]]}' \
    "$histfile" \
    | stdbuf -o0 curl -fNs "$opt_u"/v1/chat/completions -d @- \
    | stdbuf -i0 -o0 jq -Rcj --unbuffered 'foreach (inputs|if startswith("data: {") then .[6:] else empty end|fromjson) as $x ([null];[$x,.[0]];.)|. as [$x,$y]|(try $y.choices[].delta.reasoning_content catch false) as $pr|if $x.timings then [(if $pr then "\u001b[0m\n" else empty end),"\nTIME: ",($x.timings|{model:$x.model,prompt_ms,predicted_ms,predicted_n,predicted_per_second}),"\n"][] else ($x.choices[].delta|if .reasoning_content then .reasoning_content|[(if $pr then empty else "\u001b[35m" end),.][] else (if .content then .content elif .tool_calls then .tool_calls[0]|((if .id then "TOOL: \(.function.name) " else "" end)+.function.arguments) else empty end)|[(if $pr then "\u001b[0m\n" else empty end),.][] end) end' \
    | stdbuf -i0 -o0 tee -a "$outfile"

# shellcheck disable=SC2016
tac "$outfile" | awk -v a="$(printf '\033[35m')" -v b="$(printf '\033[0m')" '/^(TIME|TOOL): /{next}/^<assistant>$/{exit}index($0,b){f=1}(!f){print}index($0,a){f=0}' | tac \
    | jq -Rs '{role:"assistant",content:.}' \
    >> "$histfile"


## Tool call

tool_call=$(sed -n 's/^TOOL: //p' "$outfile")
if [ "$tool_call" ]; then
    tool_cmd=$(echo "$tool_call" | jq -rR --argjson t "$tools_int" 'split(" ")|[.[0],(.[1:]|join(" ")|fromjson|[to_entries[]|"\(.key|@sh)=\(.value|@sh)"]|join(" "))]|"env \(.[1]) sh -c \($t[.[0]].cmd|@sh)"')
    tool_result=$(eval "$tool_cmd" 2>&1)
    printf "\ncmd:  %s\nout:  %s\n\n" "$tool_cmd" "$tool_result" >&2
    id=$(date +"tc_%Y%m%d_%H%M%S")
    printf %s "$tool_call" | jq -Rsr --arg id "$id" 'split(" ")|{role:"assistant",tool_calls:[{id:$id,type:"function",function:{name:.[0],arguments:(.[1:]|join(" "))}}]}' >> "$histfile"
    printf %s "$tool_result" | jq -Rsr --arg id "$id" '{role:"tool",tool_call_id:$id,content:.}' >> "$histfile"
    "$0" -u "$opt_u" -m "$opt_m" -c "${flag_n:+-n}"
fi


## Cleanup

cleanup
