#!/bin/sh

default_u=localhost:11434 default_m=Qwen3-0.6B default_s='Respond concisely /no_think'
flag_e= flag_h= flag_l= flag_n=
opt_m=$default_m opt_s=$default_s opt_u=$default_u
prompt=''

while [ $# -ge 1 ]; do
    case "$1" in
        (-[!-][!-]*)  _1=${1#?} ; shift ; set -- "-${_1%"${_1#?}"}" "-${_1#?}" "$@" ;;
        (-e|--erase)   flag_e=1  ; shift ;;
        (-h|--help)    flag_h=1  ; shift ;;
        (-l|--list)    flag_l=1  ; shift ;;
        (-n|--noout)   flag_n=1  ; shift ;;
        (-m|--model)   opt_m="$2"; shift 2 ;;
        (-s|--system)  opt_s="$2"; shift 2 ;;
        (-u|--url)     opt_u="$2"; shift 2 ;;
        (*) prompt="$*" ; break ;;
    esac
done

# echo "flag_e=[$flag_e] flag_h=[$flag_h] flag_l=[$flag_l] flag_n=[$flag_n] opt_m=[$opt_m] opt_u=[$opt_u] opt_s=[$opt_s] prompt=[$prompt]"; exit

help(){
    echo "Usage: $0 [options ...] [prompt ...]"
    echo "       cmd | $0 [options ...]"
    echo
    echo "Options:"
    echo "  -e, --erase            Erase history before starting"
    echo "  -h, --help             Help"
    echo "  -l, --list             List models"
    echo "  -m, --model <model>    Model         (default: $default_m)"
    echo "  -n, --noout            No chat output file (still creates history)"
    echo "  -s, --system <prompt>  System prompt (default: $default_s)"
    echo "  -u, --url <url>        URL of server (default: $default_u)"
}

error(){
    echo "Error: $*" >&2; exit 1
}

missing=
for i in curl jq stdbuf; do
    if ! command -v "$i" >/dev/null; then
        missing="$missing $i"
    fi
done
[ "$missing" ] && error "command not available:$missing"

[ "$flag_h" ] && { help; exit 0; }

res=$(curl -fs "$opt_u"/v1/models 2>/dev/null)
_sta=$?
[ "$_sta" -ne 0 ] && error "getting model list: server error"

models=$(echo "$res" | jq -r '.data[].id' 2>/dev/null) # do not care newlines
_sta=$?
[ "$_sta" -ne 0 ] && error "getting model list: format error"

[ "$flag_l" ] && { echo "$models"; exit 0; }

echo "$models" | grep -qFx "$opt_m" || error "model \"$opt_m\" is not available"

outdir=$HOME/.cache/chat/
mkdir -p "$outdir"

outfile="$outdir"/chat-"$(date +%Y%m%d-%H%M%S)".txt
[ "$flag_n" ] && outfile=${TMPDIR:-/tmp}/chat-out

tmpfile=${TMPDIR:-/tmp}/chat-hist
[ "$flag_e" ] && rm -f "$tmpfile"
[ -f "$tmpfile" ] || touch "$tmpfile"

cleanup(){
    [ "$flag_n" ] && rm -f "$outfile"
}

trap cleanup INT TERM

# note: avoid including arbitrarily large strings in command parameter (use pipe instead)

#tools="[{
#    \"type\": \"function\",
#    \"function\": {
#        \"name\": \"get_time\",
#        \"description\": \"Get current time\",
#        \"parameters\": {
#            \"type\": \"object\",
#            \"properties\": {
#                \"timezone\": { \"type\": \"string\", \"description\": \"timezone\" }
#            },
#            \"required\": [\"timezone\"]
#        }
#    }
#}]"

if [ -t 0 ]; then printf %s "$prompt"; else cat; fi \
    | tee "$outfile" \
    | jq -Rs '{role:"user",content:.}' \
    >> "$tmpfile"

printf "\n\n" >> "$outfile"

jq -s --arg m "$opt_m" --arg s "$opt_s" --argjson t '[]' \
    '{model:$m,stream:true,tools:$t,messages:[{role:"system",content:$s},.[]]}' \
    "$tmpfile" \
    | stdbuf -o0 curl -fNs "$opt_u"/v1/chat/completions -d @- \
    | stdbuf -i0 -o0 jq -Rcj --unbuffered 'foreach (inputs|if startswith("data: {") then .[6:] else empty end|fromjson) as $x ([null];[$x,.[0]];.)|. as [$x,$y]|(try $y.choices[].delta.reasoning_content catch false) as $pr|if $x.choices[0].finish_reason then ["\n",($x.timings|{prompt_ms,predicted_ms,predicted_n,predicted_per_second})][] else ($x.choices[].delta|if .reasoning_content then (if $pr then .reasoning_content else ["\u001b[35m",.reasoning_content][] end) elif .content then (if $pr then ["\u001b[0m\n",.content][] else .content end) elif .tool_calls then .tool_calls[0]|(if .id then "TOOL: \(.function.name) " else .function.arguments end) else empty end) end' \
    | stdbuf -i0 -o0 tee -a "$outfile"

[ -f "$outfile" ] || exit 0

sed -n '$q;3,$p' "$outfile" \
    | jq -Rs '{role:"assistant",content:.}' \
    >> "$tmpfile"

##!/bin/sh
#
#MODEL=${MODEL:-Qwen3-32B}
#SERVER=${SERVER:-localhost:18034}
#NEWL='
#'
#S(){ stdbuf -o0 "$@"; }
#
#prompt=
#tools=
#while [ $# -ge 1 ]; do
#    case "$1" in
#        (-t) echo tool "$2" ; tools="$tools$NEWL$2" ; shift 2 ;;
#        (*) prompt="$prompt$1 " ; shift ;;
#    esac
#done
#tools='get_time:get current time:timezone=time zone:format=format (you can use %Y %m %d %H %M %S):TZ=$timezone date +"$format"
#list_files:list files in dir:dir=directory:ls "$dir"
#cat_file:show contents of a file:path=path to the file:cat "$path"'
#
#tools_api=$(echo "$tools" | jq -R 'split(":")|{type:"function",function:{name:.[0],description:.[1],parameters:.[2:-1]|{type:"object",required:[.[]|split("=")[0]],properties:[.[]|split("=")|{key:.[0],value:{type:"string",description:.[1]}}]|from_entries}}}' | jq -s .)
#
#echo "tools_api=$tools_api"
#tools_int=$(echo "$tools" | jq -R 'split(":")|{key:.[0],value:.[-1]}' | jq -s 'from_entries')
#echo "tools_int=$tools_int"
#
#now=$(date +%Y%m%d-%H%M%S)
#tmp=./"$now"
#
#jq -n --arg prompt "$prompt" '[{"role":"user","content":$prompt}]' > "$tmp-msg1"
#
#while :; do
#
#    messages="$(cat "$tmp-msg1")"
#
#    req=$(jq -n --arg model "$MODEL" --argjson tools_api "$tools_api" --argjson messages "$messages" '{"model":$model,"stream":true,"tools":$tools_api,"messages":([{"role":"system","content":"Respond concisely. /no_think"}]+$messages)}')
#
#    # echo "req=$req"
#    echo "Requesting $messages"
#
#    S curl -sN "$SERVER/v1/chat/completions" -d "$req" | jq --unbuffered -nR '
#    reduce inputs as $y (
#        { raw: "", msgs: [] };
#        .raw+=$y+"\n" as $acc
#        |if ($y|startswith("data: {")) then
#           ($y|.[6:]|fromjson|.choices[0].delta) as $x
#           |if $x.role then
#               ($acc|.msgs+=[{role:$x.role,content:""}])
#           elif ($x.reasoning_content // $x.content) then
#               (($x.reasoning_content // $x.content) as $z|($z|stderr)|
#                   $acc|.msgs[-1].content+=$z)
#           elif $x.tool_calls then
#               $x.tool_calls[0] as $y|(
#                   if $y.function.name then
#                       (("Tool: \($y.function.name) "|stderr)|
#                           ($acc|.msgs+=[{role:"tool_call",name:$y.function.name,arguments:""}]))
#                   else
#                       (($y.function.arguments|stderr)|
#                           ($acc|.msgs[-1].arguments+=$y.function.arguments))
#                   end
#               )
#           else
#               $acc # necessary
#           end
#        end
#    )
#    ' > "$tmp-res"
#    echo
#
#    jq -r .raw "$tmp-res" > "$tmp-raw"
#    jq .msgs "$tmp-res" > "$tmp-msg2"
#    # cat "$tmp-msg2"
#    jq -s 'flatten' "$tmp-msg1" "$tmp-msg2" > "$tmp-msg3"
#
#    tool_call=$(jq -r --argjson tools_int "$tools_int" '
#    [.[]|select(.role == "tool_call")]
#    |if length >= 1 then
#        .[-1] | (([.arguments|fromjson|to_entries[]|"\(.key)=\(.value|@sh)"]|join("; ")) + "; " +  $tools_int[.name])
#    else
#        empty
#    end
#    ' "$tmp-msg3")
#
#    if [ "$tool_call" ]; then
#        echo "Tool call: $tool_call"
#        tool_result=$(eval "$tool_call" 2>&1)
#        echo "Result: $tool_result"
#        jq --arg tool_result "$tool_result" '[.[]|select(.role != "tool_call")] + [{role:"tool",content:$tool_result}]' "$tmp-msg3" > "$tmp-msg4"
#        cat "$tmp-msg4" > "$tmp-msg1"
#    else
#        echo "Finished. More prompt? "
#        read -r prompt
#        if [ "$prompt" ]; then
#            jq -n --arg prompt "$prompt" '.+[{"role":"user","content":$prompt}]' "$tmp-msg3" > "$tmp-msg1"
#        else
#            break
#        fi
#    fi
#
#done
