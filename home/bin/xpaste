#!/bin/sh

wsl_paste() {
    # win32yank -o; return
    cd /

    magic=pklgds25
    tmpdir=/tmp/wslclip
    [ ! -d "$tmpdir" ] && mkdir -p "$tmpdir"
    pidfile="$tmpdir/paste_pid"
    outputfile="$tmpdir/paste_output"
    readyfile="$tmpdir/paste_ready"

    # if "pidfile cannot be read" or "pid written in pidfile no longer exists", start new daemon
    if ! read -r pid < "$pidfile" 2>/dev/null || [ ! -e "/proc/$pid/fd/0" ]; then

        # shellcheck disable=SC2016
        pwsh='
        # '$magic' wsl-xpaste-pwsh # For pgrep purpose
        $wslroot="//wsl$/'"$WSL_DISTRO_NAME"'"
        while(1){
            $got = Read-Host

            # Encode string as utf8 and then convert to base64
            #$str = Get-Clipboard -Raw # without -Raw we get an array of strings
            #$bin = ([System.Text.Encoding]::UTF8).GetBytes($str)
            #$b64 = [Convert]::ToBase64String($bin)
            #echo $b64 > "$wslroot/'"$outputfile"'"
            #echo a > "$wslroot/'"$readyfile"'"

            $a = (gcb -Raw).Replace("`r`n", "`n")                   # CRLF to LF
            [IO.File]::WriteAllText("$wslroot/'"$outputfile"'", $a) # no trailing CRLF
            echo a > "$wslroot/'"$readyfile"'"

            # "Get-Clipboard -Raw > file" has an encoding problem (which can be fixed with out-file -encoding utf8), and it also adds some garbage leading/trailing bytes
            # $str = Get-Clipboard
        }
        '

        mkdir -p "$tmpdir"

        # Run powershell and save pid
        # This writes clipboard content to $outputfile whenever something is written in stdin.
        # Simple "powershell.exe Get-Clipboard" works, but very slow
        # A dummy process is piped to powershell.exe, otherwise we cannot write to its stdin with /proc/$pid/fd/0.
        # Also powershell.exe must be piped to something other than stdout, otherwise it does not persist when not launched from terminal (e.g. from vim).
        # Replacing "while ..." with "cat" works in terminal, but not in script (infinite loop)
        while true; do sleep 100000; done | powershell.exe "$pwsh" >/dev/null &
        pid=$!
        echo $pid > "$pidfile"

    fi


    rm "$outputfile" "$readyfile" 2>/dev/null
    echo > "/proc/$pid/fd/0"
    # i=0; while [ $((i += 1)) -lt 5000 ] && [ ! -e "$readyfile" ]; do sleep .001; done
    i=0; while [ $((i += 1)) -lt 5000 ] && [ ! -e "$readyfile" ]; do :; done
    # first tr removes non-base64 characters, second tr fixes CRLF
    #cat "$outputfile" | tr -c -d "[:alnum:][+/=]" | base64 -d | tr -d ''
    cat "$outputfile"

}


## Main program

if [ -n "${IS_WSL}${WSL_DISTRO_NAME}${WSL_INTEROP}${WSL_ENV}" ]; then # wsl
    wsl_paste

elif command -v xclip > /dev/null; then # xorg
    xclip -selection clipboard -o

fi
