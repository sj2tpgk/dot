#!/bin/sh
#vim: fdm=marker fdl=0 fen

# https://codeberg.org/sj2tpgk/dot/raw/branch/master/tmux

errexit() { printf "\033[31;1mERROR: \033[0m%s\n" "$1" >&2; exit 1; }

# Env vars and paths
#   TMUX_ROOT          temporary files are stored here
#   TMUX_SHELL         bash or fish; use this shell for default-command
#   TMUX_SOCKET_NAME   socket name (if set externally, use that one)
#   TMUX_bash          bash
#   TMUX_fish          fish
#   TMUX_cleanup       removes temporary files. run when last session dies

# Environment vars
TMUX_ROOT="$PREFIX"/tmp/tmux-tmp/
export TMUX_ROOT="$TMUX_ROOT"

# Get abs path of this script
# TMUX_SCRIPT="$(cd "$(dirname "$0")"; pwd)" || errexit "could not cd to \$(dirname $0)"
# TMUX_SCRIPT="$abs"/"$(basename "$0")"
# export TMUX_SCRIPT="$TMUX_SCRIPT"

# Init (called when this script is invoked)
_init() {

    # Create "$TMUX_ROOT" directory
    [ "${TMUX_ROOT#$PREFIX/tmp/}" = "$TMUX_ROOT" ] && errexit "TMUX_ROOT $TMUX_ROOT is not in /tmp/"
    if [ -d "$TMUX_ROOT" ]; then
        rm -r -- "$TMUX_ROOT"/*
    else
        mkdir -p "$TMUX_ROOT"
    fi

    # Create $TMUX_ROOT/bin and add it to $PATH
    export PATH="$TMUX_ROOT/bin:$PATH"

    # Extract files from this script
    # TODO optimize quadratic -> linear
    # Awk prints <NR> <permission> <file> e.g. "10 +x bin/foo"
    # Directives:
    #   ####FILE <permission> <file>       Mark the beginning of the file (ends before next ####FILE)
    #                                      (optionally followed by one apace and three open-brace, will be removed)
    #   #| <string>                        Replaced with <string> (may help sh syntax highlighting)
    #   #- <string>                        This line is removed
    if [ 1 -eq 0 ]; then
        awk '/^####FILE/{sub("####FILE ","");sub("{""{{$","");print NR" "$0}' "$0" | while read -r nr permission file; do
            path="$TMUX_ROOT"/"${file##/*}"
            dir=$(dirname "$path")
            # echo "def nr=[$nr], permission=[$permission], path=[$path], dir=[$dir]"
            [ ! -d "$dir" ] && mkdir -p "$dir"
            sed "1,${nr}d;/^####/Q;/^#- /d;s/^#| //" "$0" > "$path"
            case "$permission" in
                ("--") ;;
                ("+x") chmod +x "$path" ;;
                ("*")  errexit "invalid permission specified: $permission (file=$file)" ;;
            esac
        done
    else
        # improved version: no nested loop, no duplicate mkdir
        awk -v T="$TMUX_ROOT/" -v Q="'" '
            BEGIN{nxs=0}
            /^####/{close(out);out=0}
            END{close(out);cmd="chmod +x";for(i=0;i<nxs;i++){cmd=cmd" "Q xs[i] Q};system(cmd)}
            /^#-/{next}
            out{sub("#\\| ?","");print $0>out}
            /^####FILE/{
              out=T"/"$3;outd=out;sub("/[^/]*$","",outd);
              if(!outds[outd]){system("mkdir -p "Q outd Q);outds[outd]=1}
              if($2=="+x"){xs[nxs++]=out}
            }
        ' "$0"
    fi

}

printf '\033[2 q' # block cursor

if [ "$1" = pack ]; then

    dest="$(dirname "$0")"/tmux2
    { cat "$0"; printf "\n\n\n\n"; } > "$dest"
    for i in ~/bin/*; do
        [ -f "$i" ] || continue
        echo "####FILE +x $(echo "$i" | sed 's#.*/\(bin/[^/]*\)$#\1#') {{""{"
        cat "$i" | sed 's/^/#| /' # space after bar is needed
        printf "#- }}""}\n\n\n"
    done >> "$dest"

else

    # Regen conf
    _init
    # Export env vars
    TMUX_SOCKET_NAME=${TMUX_SOCKET_NAME:-default}
    export TMUX_SOCKET_NAME="$TMUX_SOCKET_NAME"

    if [ -z "$(tmux -L "$TMUX_SOCKET_NAME" list-sessions 2>/dev/null)" ]; then
        # If no session => create one
        tmux -L "$TMUX_SOCKET_NAME" -f "$TMUX_ROOT/tmux.conf"
    else
        # If session exists => reload config and run tmux command
        echo Regenerated files in "$TMUX_ROOT"
        tmux -L "$TMUX_SOCKET_NAME" -f "$TMUX_ROOT/tmux.conf" source "$TMUX_ROOT/tmux.conf"
        tmux -L "$TMUX_SOCKET_NAME" -f "$TMUX_ROOT/tmux.conf" "$@"
    fi

fi

exit # Do not remove this exit
# ==== Shell script ends here ====


# ==== Now follows embedded files ====


####FILE +x bin/ra {{{
#!/bin/sh
f() { echo "$@"; "$@"; }
# f() { echo "$@"; }
[ "$MYKBD" = colemakdh ] && flag=a || a=""
# Note: $(x=${flag:+val1}; echo ${x:-val2}) is val1 if $flag is nonempty else val2
exec ranger --clean \
    --cmd "set show_hidden       on" \
    --cmd "set tilde_in_titlebar on" \
    --cmd "set shorten_title     3" \
    --cmd "set update_title      on" \
    --cmd "map S shell $(tmux -L "$TMUX_SOCKET_NAME" show -qvg default-command)" \
    --cmd "map $(x=${flag:+k}; echo ${x:-h}) move left=1" \
    --cmd "map $(x=${flag:+n}; echo ${x:-j}) move down=1" \
    --cmd "map $(x=${flag:+e}; echo ${x:-k}) move up=1" \
    --cmd "map $(x=${flag:+i}; echo ${x:-l}) move right=1" \
    --cmd "map $(x=${flag:+K}; echo ${x:-H}) history_go -1" \
    --cmd "map $(x=${flag:+I}; echo ${x:-L}) history_go +1" \
    --cmd "map $(x=${flag:+N}; echo ${x:-J}) move down=0.5 pages=True" \
    --cmd "map $(x=${flag:+E}; echo ${x:-K}) move up=0.5   pages=True" \
    --cmd "map $(x=${flag:+j}; echo ${x:-n}) search_next" \
    --cmd "map $(x=${flag:+J}; echo ${x:-N}) search_next forward=False" \
    --cmd "map $(x=${flag:+L}; echo ${x:-I}) eval fm.open_console('rename ' + fm.thisfile.relative_path.replace('%', '%%'), position=7)" \
    "$@"
#- }}}


####FILE +x bin/TMUX_bash {{{
#!/bin/sh
INPUTRC="$TMUX_ROOT/inputrc" exec bash --rcfile "$TMUX_ROOT/bashrc"
#- }}}


####FILE +x bin/TMUX_cleanup {{{
#!/bin/sh
# Remove $TMUX_ROOT dir when all tmux sessions are closed
if [ "$(tmux -L "$TMUX_SOCKET_NAME" list-sessions | wc -l)" = 0 ]; then
    # Ensure not to remove wrong thing
    [ "${TMUX_ROOT#$PREFIX/tmp/}" = "$TMUX_ROOT" ] && exit 1
    [ ! -d "$TMUX_ROOT" ] && exit 1
    rm -r "$TMUX_ROOT"
fi
#- }}}


####FILE +x bin/TMUX_fish {{{
#!/bin/sh
sav=$XDG_CONFIG_HOME
export XDG_CONFIG_HOME="$TMUX_ROOT/config"
export SHELL=TMUX_fish
if [ -z "$sav" ]; then
    exec fish -C "set -e XDG_CONFIG_HOME"
else
    exec fish -C "set -xg XDG_CONFIG_HOME '$sav'"
fi
#- }}}


####FILE +x bin/v {{{
#!/bin/sh
if command -v vim >/dev/null; then
    SHELL=sh exec vim -u "$TMUX_ROOT/vimrc" "$@"
elif command -v nvim >/dev/null; then
    SHELL=sh exec nvim -u "$TMUX_ROOT/vimrc" "$@"
elif command -v nano >/dev/null; then
    exec nano "$@"
elif command -v emacs >/dev/null; then
    exec emacs -nw -Q --color=yes "$@"
elif command -v vi >/dev/null; then
    exec vi "$@"
else
    echo "No editor found"
fi
#- }}}


####FILE -- config/fish/config.fish {{{
[ -d "/data/data/com.termux/files/home/bin/" ] \
    && set -x PATH $PATH:/data/data/com.termux/files/home/bin/
set fish_color_autosuggestion magenta
set fish_color_command cyan
#| function fish_greeting; end
#| function mkcd; mkdir -p $argv[1] && cd $argv[1]; end
#| for i in f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12; bind -k $i ""; end
#| for i in \e\[25\;2~ \e\[26\;5~; bind $i ""; end
#| bind \eg "commandline -r (commandline -b | sed 's#\s*\$# | grep -i #')"
#| command -v doas >/dev/null 2>&1 && alias sudo doas
#- }}}


####FILE -- bashrc {{{
conf() { sed "0,/^#===$1/d;/^#===/Q;s/^###//" "$TMUX_CONF"; }
command -v nvim >/dev/null && nv() { nvim -u <(conf vim) "$@"; }
command -v vim  >/dev/null && v()  { vim  -u <(conf vim) "$@"; }
_exitstatus() { local s=$?; [[ $s == 0 ]] && echo "" || echo -e "\e[31m$s\e[0m "; }
export PS1="\[\e[36m\]\w\[$(tput sgr0)\] \$(_exitstatus)>>> "
mkcd() { mkdir -p "$1" && cd "$1"; }
alias la='ls -la'
#- }}}


####FILE -- inputrc {{{
Tab:    menu-complete
"\e[Z": complete
"\C-w": shell-backward-kill-word
"\e[A": history-search-backward
"\e[B": history-search-forward
set show-all-if-ambiguous        on  # Tab -> partial completion and show candidates
set show-all-if-unmodified       on  #
set colored-stats                on  # Color files by types
set visible-stats                on  # Append char to indicate type
set mark-symlinked-directories   on  # Mark symlinked directories
set colored-completion-prefix    on  # Color the common prefix
set menu-complete-display-prefix on  # Color the common prefix in menu-complete
set eo-control-characters        off # Don't show ^C etc.
set enable-bracketed-paste       off # Workaround (https://github.com/hanslub42/rlwrap/issues/108)
set completion-ignore-case       on  # Case insensitive completion
#- }}}


####FILE -- tmux.conf {{{
set -g default-shell /bin/sh
set-hook -g session-closed 'run TMUX_cleanup'

# Seems "setenv -g" does not affect variables within .tmux.conf (but do affect in child proc)
EDITOR="$TMUX_ROOT/bin/v"
VISUAL="$TMUX_ROOT/bin/v"

# Set shell ( if $TMUX_SHELL is set, use that shell )
if "if [ -n '#{TMUX_SHELL}' ]; then [ fish = '#{TMUX_SHELL}' ]; else command -v fish >/dev/null; fi" {
    set -g default-command 'TMUX_fish'
    # set -g default-command 'exec fish -C "function conf; sed \"0,/^#===\$argv[1]/d;/^#===/Q;s/^###//\" \"'"$TMUX_CONF"'\"; end; conf fish | source"' # exec needed? to change cwd of pane process
} {
    set -g default-command 'TMUX_bash'
    # set -g default-command 'd=$(mktemp -d "$PREFIX"/tmp/tmux-temp-conf-XXXXXX); sed "0,/^#===inputrc/d;/^#===/Q;s/^###//" '"$TMUX_CONF"' > "$d/1"; sed "0,/^#===bash/d;/^#===/Q;s/^###//" '"$TMUX_CONF"' > "$d/2"; INPUTRC="$d/1" bash --init-file "$d/2"; rm "$d/1" "$d/2"; rmdir "$d"'
}

set -g escape-time 0
set -g mouse       on

run-shell -b 'p=$(myprompt -- --tmux --short | sed "s/ .*//"); tmux set -g status-left "#[nobold]$p [##S] "'
set -g status-left-length 20
set -g status-right       '#{s#^'$HOME'#~#;s#/\$##;s#([-._]*[^/])[^/]*/#\1/#g:pane_current_path} [#{s/^(..)...*(..)$/\1.\2/:user}@#{s/^(..)...*(..)$/\1.\2/:host}]'
set -g status-position    top
set -g pane-active-border-style fg=yellow

set -g status-style                 bg=0,fg=7,bold
set -g window-status-style          bg=0,fg=1,bold
set -g window-status-current-style  bg=0,fg=1,bold,reverse
set -g window-status-format         " #I:#W#F "
set -g window-status-current-format " #I:#W#F "
set -g window-status-separator      ""

bind    '"'   split-window -vc "#{pane_current_path}"
bind    s     split-window -vc "#{pane_current_path}"
bind    %     split-window -hc "#{pane_current_path}"
bind    v     split-window -hc "#{pane_current_path}"
bind    w     new-window   -c  "#{pane_current_path}"
bind    r     run "$TMUX_SCRIPT" \; source "$TMUX_ROOT/tmux.conf" \; display "Reloaded .tmux.conf"
bind -r o     select-pane -t :.+
bind -r n     next-window
bind -n F3    next-window
bind -n F4    select-pane -t :.+
bind -r Left  resize-pane -L 1
bind -r Down  resize-pane -D 1
bind -r Up    resize-pane -U 1
bind -r Right resize-pane -R 1
bind -r <     swap-pane -d -t -1
bind -r >     swap-pane -d -t +1

# Completion using fzf
bind    Tab      run "$TMUX_ROOT/bin/tmux-comp"

# Use xcopy if exists (todo: add to main config)
if-shell "command -v xcopy >/dev/null" "set -q copy-command xcopy"

# hide status on zoom
set-hook -g after-resize-pane 'if "[ #{window_zoomed_flag} -eq 1 ]" "set -g status off" "set -g status on"'

# Load local config
if-shell "test -f '$HOME/.tmux.conf.local'" { source "$HOME/.tmux.conf.local" }
#- }}}


####FILE -- vimrc {{{
#| " vim
#| if filereadable($VIMRUNTIME . "/defaults.vim") | source $VIMRUNTIME/defaults.vim | endif
#| set et nocp sm hid nosc
#| syntax on| filetype on| filetype plugin indent on
#| set ls=2 stl=[%{&readonly?'R':''}%{&modified?'+':'-'}]\ \ %<%f%*%=%-10.(%l,%c%V%)\ %y%6.(%P%)
#| nn s/ :noh<cr>:let @/ = ""<cr>
#| " neovim
#| set ai sw=4 ts=4 sr mouse=av so=1 siso=5 tw=0 nu sb spr cf acd wic ic scs is hls ttm=0 t_Co=16
#| for i in range(1, 16) | for j in ["", "s-", "c-"] | for k in ["", "i", "c"] | exe k . "nore <" . j . "f" . i . "> <nop>" | endfor | endfor | endfor
#| nn Q :q<cr>| ino <s-f13> <nop>| ino <c-f14> <nop>| nn D dd| nn Y yy| nn ss :sp<cr>| nn sv :vsp<cr>| nn sb :bd<cr>| nn so <c-w>o| nn :<cr> :wa<cr>| nn <a-j> J| nn - <c-w>w| nnore + :tabnext<cr>| nn > >>| nn <lt> <lt><lt>| nn U <c-r>| nno <space> <c-d>| nno <backspace> <c-u>| no <cr> K
#| " no <esc>[25;2~ <nop>| ino <esc>[25;2~ <nop>| no <esc>[26;5~ <nop>| ino <esc>[26;5~ <nop>
#| no j gj| no k gk| no gj j| no gk k| no J <c-d>| no K <c-u>| no h h| no l l| no gh 0| no gl <end>| no i i| no I I| no si s| no n n| no N N| no e e| no E E| ono e e| ono E E| ono h 0| ono l $| ono iw iw| ono iW iW| nno H <c-o> |nno L <c-i>
#| if $MYKBD == "colemakdh" | no n gj| no e gk| no gn j| no ge k| no N <c-d>| no E <c-u>| no k h| no i l| no gk 0| no gi <end>| no l i| no L I| no sl s| no j n| no J N| no h e| no H E| ono h e| ono H E| ono k 0| ono i $| ono lw iw| ono lW iW| nno K <c-o> |nno I <c-i> | endif
#| ono m %| nn m %| nn yb mzggVGy'z| nn db mzggVGd'z
#| exe "au InsertEnter * set cul"| exe "au InsertLeave * set nocul"
#|
#| if has("nvim") | exe "au ColorScheme * set notgc | hi Pmenu ctermfg=1 ctermbg=0" | colo vim | endif
#|
#| " Save/restore view
#| aug view
#| au!
#| au BufWinLeave * if expand('%') != '' && &bt !~ 'nofile' | sil! cal mkdir(&vdir,'p') | mkvie | end
#| au BufWinEnter * if expand('%') != '' && &bt !~ 'nofile' | sil! lo | end
#| aug END
#|
#| " Clipboard
#| set clipboard=unnamedplus
#| " If my clipboard wrapper is available, use it.
#| if executable("xcopy") && executable("xpaste")
#|     let g:clipboard = { 'name': 'my', 'copy': { '+': 'xcopy', '*': 'xcopy', }, 'paste': { '+': 'xpaste', '*': 'xpaste', }, 'cache_enabled': 1, }
#| endif
#|
#| " Basic auto completion
#| inore <tab>       <c-n>
#| inore <plug>MyTab <c-n>
#| inore <s-tab>     <c-p>
#| inore <expr> <cr> pumvisible() ? "\<c-y>\<cr>" : "\<cr>"
#| set shm+=c cot=menuone,noinsert,noselect noinf
#| " Auto complete (https://stackoverflow.com/questions/35837990)
#| fu! OpenCompletion()
#|     " check (menu invisible && inserting iskeyword char && at least minlen chars)
#|     let minlen = 2
#|     if !pumvisible() && (v:char =~ '\K') && (minlen == 1 || (col(".") >= (minlen-1) && matchstr(getline("."), '\%' . (col('.')-(minlen-1)) . 'c\K\{' . (minlen-1) . '\}') != ""))
#|         call feedkeys("\<plug>MyTab", "")
#|         " feedkeys("\<c-n>", "") will mess up repeating
#|     endif
#| endfu
#| " au InsertCharPre * call OpenCompletion()
#|
#| " Basic linter integration (press | key)
#| nnore <bar> :sil call Linter(0)<cr>
#| " au CursorHold *.pl call Linter(1)
#| set updatetime=700
#| au FileType sh setl makeprg=shellcheck\ -f\ gcc\ %:S
#| au FileType perl setl makeprg=perlcritic\ --verbose\ 1\ -3\ %:S
#| set ar aw
#| fu! Linter(nomove)
#|     let qf = 0 " quickfix open?
#|     for i in range(1, winnr('$')) | let qf += getwinvar(i, '&syntax') == 'qf' | endfo
#|     if empty(bufname("."))
#|         return
#|     elseif (getbufinfo(".")[0].changed || !qf) && executable(split(&makeprg)[0])
#|         let [s1, s2] = [winnr(), getpos(".")]
#|         sil make | cope
#|         while winnr() != s1 | exec "norm! \<c-w>w" | endwh | call setpos(".", s2)
#|     elseif !a:nomove
#|         try | cnext | catch | cfirst | endtry
#|     endif
#|     " For neovim, check vim.diagnostic.{show,fromqflist}, vim.system, vim.schedule
#| endf
#- }}}




####FILE +x bin/7zenc {{{
#| #!/bin/sh
#| 
#| [ $# -le 1 ] && { echo "Usage: $0 [-n] <archive_name> [<file_names> ...]"; echo "  -n  no password in file name"; exit 1; }
#| nopass=0
#| [ "$1" = -n ] && { nopass=1; shift; }
#| arc=$1
#| shift
#| [ "${arc%.7z}" = "$arc" ] && { echo "archive name not ending with .7z"; exit 1; }
#| pw=$(tr -dc '0-9a-z' </dev/urandom | head -c 10)
#| [ "$nopass" = 0 ] && arc="${arc%.7z}-$pw.7z"
#| 7z a -bb0 -mhe=on -p"$pw" "$arc" "$@"
#| echo
#| echo "Password: $pw"
#- }}}


####FILE +x bin/archsetup {{{
#| #!/bin/sh
#| 
#| # Install essential packages
#| 
#| # Usage: archsetup [-n] [-y]
#| # Options:
#| #    -n   dry run
#| #    -y   yes to all
#| 
#| dryrun= yes=
#| while [ $# -ge 1 ]; do case "$1" in (-n) dryrun=1;; (-y) yes=1;; esac; shift; done
#| 
#| ask() {
#|     if [ "$dryrun" ]; then printf "> %s\n" "$*"; return 0; fi
#|     if [ "$yes" ]; then ask_answer=y; else printf "%s [y/n] " "$*"; read -r ask_answer; fi
#|     if test "$ask_answer" == y; then echo "$@"; fi
#| }
#| 
#| ask pacman --noconfirm -S anthy atool bluez bluz-utils dash entr fish fzf git imagemagick jq keyd man man-db neovim nmap openssh pv ranger rsync tmux pv udiskie w3m wget
#| 
#| ask pacman --noconfirm -S foot mpv wl-clipboard wlr-randr
#| 
#| ask pacman --noconfirm -S claws-mail firefox mousepad pcmanfm
#| 
#| ask pacman --noconfirm -S docker
#- }}}


####FILE +x bin/args {{{
#| #!/bin/sh
#| 
#| idx=1
#| for i in "$@"; do
#|     printf "%s\t[%s]\n" "$idx" "$i"
#|     idx=$((idx + 1))
#| done
#- }}}


####FILE +x bin/c {{{
#| #!/bin/sh
#| 
#| if [ -t 1 ]; then
#|     if command -v highlight >/dev/null 2>&1; then
#|         exec highlight --out-format ansi --stdout --force "$@"
#|     elif command -v bat >/dev/null 2>&1; then
#|         exec bat --theme ansi -p -P "$@"
#|     else
#|         exec cat "$@"
#|     fi
#| else
#|     exec cat "$@"
#| fi
#- }}}


####FILE +x bin/colorscheme {{{
#| #!/bin/sh
#| 
#| colors=${1:-myd}
#| output=${2:-foot}
#| 
#| f_rangef() {
#|     # f_range a b x
#|     # convert 0..a to 0..b
#|     awk "BEGIN{printf \"%f\", ($2*$3)/($1); exit}"
#| }
#| 
#| colors_myd() {
#|     back=10191f
#|     fore=c6cfd8
#|     curf=222222
#|     curb=f9f5f4
#|     alph=85
#| 
#|     dk=18262F
#|     bk=38464F
#|     dr=EF5253
#|     br=FF6263
#|     dg=7CC844
#|     bg=8CD854
#|     dy=E4B51C
#|     by=F4C52C
#|     db=33B5E1
#|     bb=43C5F1
#|     dm=A363D5
#|     bm=B373E5
#|     dc=52CBB0
#|     bc=62DBC0
#|     dw=C6CfD8
#|     bw=D6DFD8
#| }
#| 
#| colors_myb() {
#|     back=f4f2f2
#|     fore=444433
#|     curf=f4f2f2
#|     curb=333333
#|     alph=93
#| 
#|     dk=f8f4f4
#|     bk=f8f4f4
#|     dr=ee2222
#|     br=ff3333
#|     dg=006600
#|     bg=228822
#|     dy=c07700
#|     by=c88018
#|     db=1111aa
#|     bb=3333cc
#|     dm=aa5599
#|     bm=bb66aa
#|     dc=008888
#|     bc=00aaaa
#|     dw=444433
#|     bw=444433
#| }
#| 
#| copy_colors() {
#|     # c_d_0=$dk c_b_0=$bk c_0=$dk c_8=$bk
#|     j=0
#|     for i in k r g y b m c w; do
#|         eval "c_d_$j=\$d$i c_b_$j=\$b$i c_$j=\$d$i c_$((j + 8))=\$b$i"
#|         j=$((j + 1))
#|     done
#| }
#| 
#| output_foot() {
#|     # echo \-o colors.regular2=ff0000
#|     for i in $(seq 0 7); do eval "printf '%s ' \"-o colors.regular$i=\$c_d_$i\""; done
#|     for i in $(seq 0 7); do eval "printf '%s ' \"-o colors.bright$i=\$c_b_$i\""; done
#|     printf '%s ' "-o colors.foreground=$fore"
#|     printf '%s ' "-o colors.background=$back"
#|     printf '%s ' "-o colors.alpha=$(f_rangef 100 1.0 "$alph")"
#| }
#| 
#| output_osc4() {
#|     # /bin/printf '\033]4;2;#ff0000;\007'
#|     for i in $(seq 0 7); do eval "/bin/printf '\\033]4;$i;#\$c_d_$i;\\007'"; done
#|     for i in $(seq 0 7); do eval "/bin/printf '\\033]4;$i;#\$c_b_$i;\\007'"; done
#| }
#| 
#| if ! type "colors_$colors" 2>/dev/null | grep -q function; then
#|     echo "color scheme '$colors' is not defined"
#|     exit 1
#| elif ! type "output_$output" 2>/dev/null | grep -q function; then
#|     echo "output type '$output' is not defined"
#|     exit 1
#| fi
#| 
#| "colors_$colors"
#| copy_colors
#| "output_$output"
#- }}}


####FILE +x bin/dt {{{
#| #!/bin/sh
#| 
#| date +"%Y%m%d-%H%M%S"
#- }}}


####FILE +x bin/du1 {{{
#| #!/bin/sh
#| 
#| du -d1 -BM $1 | sort -n
#- }}}


####FILE +x bin/du2 {{{
#| #!/bin/sh
#| 
#| du -d2 -BM $1 | sort -n
#- }}}


####FILE +x bin/ec {{{
#| #!/bin/sh
#| 
#| # emacsclient -a nano -nw -c "$@"
#| 
#| if [ -n "$TMUX" ]; then
#|   # TERM=xterm-direct emacsclient -a nano -c -nw "$@"
#| 
#|   # Non-truecolor (when using rxvt-unicode packge)
#|   TERM=xterm-256color emacsclient -a nano -c -nw "$@"
#| else
#|   TERM=st-direct emacs -a nano -c -nw "$@"
#| fi
#| 
#- }}}


####FILE +x bin/en {{{
#| #!/bin/sh
#| 
#| # emacs -nw --color=yes "$@"
#| # emacs -nw --color=auto "$@"
#| # TERM=screen-16color
#| # emacs -nw --color=256 "$@"
#| 
#| # Guide for emacs + tmux + truecolor
#| # When using urxvt-truecolor
#| # In .tmux.conf
#| #   default-terminal = screen-256color
#| #   terminal-overrides = ",$TERM:Tc"
#| #   ($TERM gets expanded to default-terminal (screen-256color)
#| # When launching emacs,
#| #   if inside  tmux, use TERM=xterm-direct
#| #   if outside tmux, use TERM=st-direct
#| # Diagnose:
#| #   - check if 24bit-colors.sh show smoothly changing colors
#| #   - "TERM=xxxx emacs -nw -Q --eval '(list-colors-display)'"
#| #     to check (1) it shows 500~ colors and (2) color code emacs says and that of colorpicker matches.
#| # Still a problem:
#| #   if server run on low colors and client in true-color, crash.
#| 
#| if [ -n "$TMUX" ]; then
#|   emacs -nw --color=yes "$@"
#|   # TERM=xterm-direct emacs -nw "$@"
#| 
#|   # Non-truecolor (when using rxvt-unicode packge)
#|   # TERM=screen-256color emacs -nw "$@"
#| else
#|   emacs -nw --color=yes "$@"
#|   # TERM=st-direct emacs -nw "$@"
#| fi
#| 
#- }}}


####FILE +x bin/finddupe {{{
#| #!/bin/sh
#| 
#| usage () {
#|     echo -e "Usage: ./finddupe [options...] [directory]"
#|     echo -e "Options:"
#|     echo -e "    -l      list unnecessary files"
#|     echo -e "    -h      print help"
#| }
#| 
#| lflag=0
#| if [ "$1" = -h ]; then usage; exit; fi
#| if [ "$1" = -l ]; then lflag=1; shift; fi
#| 
#| dir=${1:-.}
#| 
#| 
#| # f output lines of the form "<hash>  <file>"
#| # f(){ find "$dir" -type f | while read f; do xxhsum "$f"; done; }
#| # f(){ find "$dir" -type f | while read f; do md5sum "$f"; done; }
#| # f(){ find "$dir" -type f | while read f; do cksum "$f"; done | cut -d' ' -f2 --complement; }
#| f(){ du -ab "$dir"; }
#| 
#| # detect dupes in f's output
#| # $h=hash, $l=prev line, $x=to avoid dup line on >=3 consequtive matches
#| g(){ sort | perl -nae 'BEGIN{$h=-1;$l=""}if($h eq $F[0]){print $l if $x;$x=0;print}else{$x=1}$l=$_;$h=$F[0]'; }
#| 
#| # in output of g, print except first
#| r(){ perl -nae 'BEGIN{$h=-1}if($h eq $F[0]){print}$h=$F[0]'; }
#| 
#| # f | g
#| 
#| # first by size (fast), then hash
#| if [ $lflag -eq 1 ]; then
#|     f | g | cut -f2 | while read f1; do xxhsum "$f1"; done | g | r
#| else
#|     f | g | cut -f2 | while read f1; do xxhsum "$f1"; done | g
#| fi
#- }}}


####FILE +x bin/findimg {{{
#| #!/bin/sh
#| 
#| find . -type f | sed -rn '/(bmp|gif|jpeg|jpg|png|webm)/Ip' | sort
#- }}}


####FILE +x bin/gorun {{{
#| #!/bin/sh
#| 
#| [ $# -eq 0 ] && { echo >&2 "Usage: gorun [-b] file.go"; exit 1; }
#| 
#| if [ "$1" = -b ]; then build=1; shift; else build=; fi
#| f=$1
#| 
#| if [ "$build" ]; then
#|     gofmt -w "$f" && goimports -w "$f" && go build -o "${f%.go}" "$@"
#| else
#|     gofmt -w "$f" && goimports -w "$f" && go run "$@"
#| fi
#- }}}


####FILE +x bin/haropen {{{
#| #!/bin/python
#| 
#| import argparse, base64, json, os, re
#| 
#| # TODO Dump as text
#| 
#| def nonDupeFilename(basename, files):
#|     file = basename
#|     j = 0
#|     while file in files:
#|         j += 1
#|         file = f"{basename}_{j}"
#|     return file
#| 
#| parser = argparse.ArgumentParser()
#| parser.add_argument("-f", "--format", type=str, default="{file}")
#| parser.add_argument("-o", "--outdir", type=str, default="")
#| parser.add_argument("infile")
#| args = parser.parse_args()
#| 
#| infile = args.infile
#| outdir = args.outdir if len(args.outdir) else re.sub(r"[^][_.()a-zA-Z0-9-]", "_", re.sub(r"\.har", "", infile))
#| format = args.format
#| fmtDictExample = {
#|     "index":  True,
#|     "file":   True,
#|     "status": True,
#|     "method": True,
#|     "type":   True,
#|     "time":   True,
#| }
#| 
#| try:
#|     format.format(**fmtDictExample)
#| except:
#|     print("Invalid format:", format)
#|     print("Valid keys are:", ", ".join(list(fmtDictExample.keys())))
#|     print("Example: -f '{index} {file}'")
#|     exit(1)
#| 
#| if os.path.exists(outdir):
#|     if not os.path.isdir(outdir):
#|         exit(1)
#| else:
#|     os.mkdir(outdir)
#| 
#| with open(infile, "rb") as f:
#|     har = json.load(f)
#| 
#| outfiles = {}
#| 
#| for i, e in enumerate(har["log"]["entries"]):
#|     basename = re.sub(r".*/", "", e["request"]["url"]) #TODO format
#|     if len(basename) == 0: basename = "(empty filename)"
#|     # response body
#|     content = e["response"]["content"]
#|     fmtDict = {
#|         "index":  i,
#|         "file":   basename,
#|         "status": e["response"]["status"],
#|         "method": e["request"]["method"],
#|         "type":   "mimeType" in content and content["mimeType"].replace("/", "_"),
#|         "time":   e["time"],
#|     }
#|     outbase = format.format(**fmtDict)[:200]
#|     outfile = nonDupeFilename(outbase, outfiles)
#|     outfiles[outfile] = True
#|     if not "text" in content:
#|         print(f"{i}\t---\t{outfile}")
#|     elif content["text"]:
#|         if content.get("encoding") == "base64":
#|             print(f"{i}\tb64\t{outfile}")
#|             with open(outdir + os.sep + outfile, "wb") as f:
#|                 f.write(base64.b64decode(content["text"]))
#|         else:
#|             print(f"{i}\ttext\t{outfile}")
#|             with open(outdir + os.sep + outfile, "w") as f:
#|                 f.write(content["text"])
#|     else:
#|         print(f"{i}\t---\t{outfile}")
#|     # request body
#|     if "postData" in e["request"]:
#|         postData = e["request"]["postData"]["text"]
#|         with open(outdir + os.sep + outfile + ".req", "w") as f:
#|             f.write(postData)
#| 
#| 
#- }}}


####FILE +x bin/im-ascii {{{
#| #!/bin/sh
#| [ $# -eq 0 ] && { echo "Usage: $0 image"; exit 1; }
#| magick "$1" -geometry "$(($(tput cols) - 1))x" -colorspace Gray -colors 8 txt: | sed -n 's/\([0-9][0-9]*\),\([0-9][0-9]*\).*(\([0-9][0-9]*\).*/\1 \2 \3/p' | awk 'BEGIN{T="#+- "}{if($2%2<=0){if(y!=$2){print "";y=$2}v=($3/100)*length(T);v=v-(v%1);c=substr(T,v+1,1);printf c}}END{print ""}'
#- }}}


####FILE +x bin/im-diff {{{
#| #!/bin/sh
#| [ $# -eq 0 ] && { echo "Usage: $0 image1 image2 [fuzz%] [outfile]"; exit 1; }
#| image1=$1
#| image2=$2
#| fuzz=${3:-10%}
#| out=${4:-NULL:}
#| 
#| wh=$(magick identify -ping -format '%w %h' "$image1")
#| w=${wh% *}
#| h=${wh#* }
#| 
#| ae=$(magick compare -fuzz "$fuzz" -metric AE \
#|     \( -resize "${w}x${h}" "$image1" \) \
#|     \( -resize "${w}x${h}" "$image2" \) \
#|     "$out" 2>&1)
#| 
#| echo "$w,$h,$ae"
#| echo $(( ( 100 * ae ) / ( w * h ) ))
#| 
#- }}}


####FILE +x bin/im-sixel {{{
#| #!/bin/sh
#| [ $# -eq 0 ] && { echo "Usage: $0 image [width]"; exit 1; }
#| magick "$1" -geometry "x${2:-100}" sixel:-
#- }}}


####FILE +x bin/img2txtfull {{{
#| #!/usr/bin/perl
#| 
#| my $img = $ARGV[0];
#| 
#| my $tw = `tput cols`;
#| my $th = `tput lines` - 1;
#| 
#| my ($iw, $ih) = split(" ", `identify -format "%w %h" "$img"`);
#| 
#| # print "$tw,$th,$iw,$ih\n";
#| if ($iw/$ih > $tw/$th) {
#|     system("img2txt -W $tw -g 0.6 $img")
#| } else {
#|     system("img2txt -H $th -g 0.6 $img")
#| }
#- }}}


####FILE +x bin/imgsearch {{{
#| #!/bin/sh
#| 
#| input=$*
#| # echo "[$input]"
#| rclip -f -t 30 "$input" 2>/dev/null | grep -v TensorList | sxiv -t -i -
#- }}}


####FILE +x bin/install-tools {{{
#| #!/bin/sh
#| 
#| if command -v pacman >/dev/null; then
#|     pacman -S tmux vim fish git ranger
#| elif command -v apt >/dev/null; then
#|     apt install tmux vim fish git ranger
#| fi
#- }}}


####FILE +x bin/l {{{
#| #!/bin/bash
#| 
#| # Argument transposer
#| 
#| die() { echo "Error: $*" >&2; exit 1; }
#| 
#| f() {
#|     local a=()
#|     local b=()
#|     local c=()
#|     # Separate at last --
#|     # l x1 -- x2 x3 -- x4 x5 ==> a=(x1 -- x2 x3), b=(-- x4 x5)
#|     for i in "$@"; do
#|         if [[ "$i" = -- ]]; then
#|             a+=("${b[@]}")
#|             b=()
#|         fi
#|         b+=("$i")
#|     done
#|     # No -- ==> exit
#|     [[ "${#a[@]}" -eq 0 ]] && die "no -- found"
#|     # Remove -- from b
#|     b=("${b[@]:1}")
#|     # Substitute -- and --- in a
#|     for i in "${a[@]}"; do
#|         if [[ "$i" = -- ]]; then
#|             [[ "${#b[@]}" -eq 0 ]] && die "too few args"
#|             c+=("${b[0]}")
#|             b=("${b[@]:1}")
#|         elif [[ "$i" = --- ]]; then
#|             [[ "${#b[@]}" -eq 0 ]] && die "too few args"
#|             c+=("${b[@]}")
#|             b=()
#|         else
#|             c+=("$i")
#|         fi
#|     done
#|     [[ "${#b[@]}" -gt 0 ]] && die "too many args"
#|     # echo "a=(${a[*]}), b=(${b[*]}), c=(${c[*]})"
#|     # Run command
#|     "${c[@]}"
#| }
#| 
#| # [[ "$(f echo a -- b -- c)"      == "a c b"   ]] || echo fail
#| # [[ "$(f echo a -- -- b -- c d)" == "a c d b" ]] || echo fail
#| # [[ "$(f echo a --- b -- c d)"   == "a c d b" ]] || echo fail
#| 
#| f "$@"
#- }}}


####FILE +x bin/lft {{{
#| #!/bin/sh
#| 
#| [ "$MYKBD" = colemakdh ] && flag=a || a=""
#| 
#| # shellcheck disable=SC2016
#| lfrc='
#| set mouse
#| set cursorpreviewfmt "" # cursor in preview pane "\033[7;2m"
#| 
#| map s shell-wait
#| map S $$SHELL
#| map x !$f
#| 
#| map H jump-prev
#| map L jump-next
#| 
#| map <enter> open
#| map O &xdg-open $fx
#| 
#| map r
#| map a rename
#| # map I :rename; cmd-home
#| map A :rename; cmd-end
#| map C :rename; cmd-end; cmd-delete-home
#| 
#| map w $tmux -L lf neww $SHELL
#| map S $tmux -L lf neww $SHELL
#| 
#| cmd open ${{
#|     tmux -L lf neww ${VISUAL:-EDITOR} $fx
#| }}
#| 
#| map <c-z> $kill -STOP "$PPID"
#| map <f-7> push &mkdir<space>-p<space>
#| map <f-8> trash
#| 
#| map zt push &touch<space>
#| map zm push &mkdir<space>-p<space>
#| map zd delete
#| 
#| map on :set sortby natural; set info
#| map os :set sortby size; set info size
#| map ot :set sortby time; set info time
#| map oa :set sortby atime; set info atime
#| map oc :set sortby ctime; set info ctime
#| map oe :set sortby ext; set info
#| 
#| # trash command
#| cmd trash %set -f; mv $fx ~/.trash
#| %mkdir -p ~/.trash
#| 
#| # delete command
#| cmd delete ${{
#|     set -f # disable globbing
#|     printf "$fx\n"
#|     printf "delete? [y/n]"
#|     read ans
#|     [ "$ans" = "y" ] && rm -rf $fx
#| }}
#| 
#| # extract the current file with the right command
#| # (xkcd link: https://xkcd.com/1168/)
#| cmd extract ${{
#|     set -f
#|     atool --list --each -- $fx
#|     atool --extract --each -- $fx
#| }}
#| 
#| # compress current file or selected files with tar and gunzip
#| cmd tar ${{
#|     set -f
#|     mkdir $1
#|     cp -r $fx $1
#|     tar czf $1.tar.gz $1
#|     rm -rf $1
#| }}
#| 
#| # compress current file or selected files with zip
#| cmd zip ${{
#|     set -f
#|     mkdir $1
#|     cp -r $fx $1
#|     zip -r $1.zip $1
#|     rm -rf $1
#| }}
#| '
#| 
#| lfrc="
#| $lfrc
#| map $(x=${flag:+k}; echo ${x:-h}) updir
#| map $(x=${flag:+n}; echo ${x:-j}) down
#| map $(x=${flag:+e}; echo ${x:-k}) up
#| map $(x=${flag:+i}; echo ${x:-l}) open
#| map $(x=${flag:+K}; echo ${x:-H}) jump-prev
#| map $(x=${flag:+I}; echo ${x:-L}) jump-next
#| map $(x=${flag:+N}; echo ${x:-J}) half-down
#| map $(x=${flag:+E}; echo ${x:-K}) half-up
#| map $(x=${flag:+j}; echo ${x:-n}) search-next
#| map $(x=${flag:+J}; echo ${x:-N}) search-prev
#| map $(x=${flag:+L}; echo ${x:-I}) :rename; cmd-home
#| "
#| 
#| # shellcheck disable=SC2016
#| tmuxconf='
#| # Shell
#| set -g default-shell /bin/sh
#| set -g default-command "SHELL=$SHELL exec lf -config \"$MYLF_LFRC\"" # without exec, pane_current_command remains $SHELL
#| 
#| # Mouse
#| # set -g mouse on
#| # bind -n WheelDownPane  send Down
#| # bind -n WheelUpPane    send Up
#| # bind -n MouseDown1Pane send right
#| # bind -n MouseUp1Pane   send left
#| 
#| # We expect files are opened from lf in a new tmux window
#| bind    d display -p "#{pane_current_command} #W #I"
#| bind -n T   if "test \"#{pane_current_command}\" = lf" "neww"         "send T"
#| bind -n Q   if "test \"#{pane_current_command}\" = lf" "kill-session" "send Q"
#| bind -n Tab if "test \"#{pane_current_command}\" = lf" "next"         "send Tab"
#| 
#| # Status
#| set -g status-style                 bold,fg=white,bg=black
#| set -g status-position              top
#| set -g status-justify               right
#| set -g status-left                  "[ LF File Manager ]"
#| set -g status-left-length           25
#| set -g status-right                 ""
#| set -g window-status-current-style  fg=black,bg=green
#| set -g window-status-format         " #I#{s/^lf$//:window_name} "
#| set -g window-status-current-format " #I#{s/^lf$//:window_name} "
#| '
#| 
#| export MYLF_LFRC=/tmp/mylfrc
#| echo "$lfrc" > "$MYLF_LFRC"
#| 
#| export MYLF_TMUXCONF=/tmp/mylftmuxconf
#| echo "$tmuxconf" > "$MYLF_TMUXCONF"
#| 
#| exec tmux -L lf -f "$MYLF_TMUXCONF" new
#- }}}


####FILE +x bin/lisp {{{
#| #!/bin/sh
#| 
#| if [ "$TERM" = dumb ] || [ $# -ge 1 ]; then
#|     exec sbcl "$@"
#| else
#|     exec rlwrap -p'3;32' \
#|         --remember \
#|         --history-filename="$HOME/.rlwrap/sbcl_history" \
#|         --histsize=1000000 \
#|         --complete-filenames \
#|         --break-chars "$BREAK_CHARS" \
#|         sbcl
#|         # --file="$HOME/.rlwrap/sbcl_completions" \
#| fi
#| exit
#| 
#| BREAK_CHARS="(){}[],^%$#@\"\";''|\\"
#| RLWRAP=
#| if [ $TERM == "dumb" ]; then  # slime
#|   RLWRAP=
#| else
#|   RLWRAP="rlwrap -p3;32 --remember --history-filename=$HOME/.rlwrap/sbcl_history --histsize=1000000 -c -b $BREAK_CHARS -f $HOME/.rlwrap/sbcl_completions"
#| fi
#| if [ $# -eq 0 ]; then
#|   exec $RLWRAP /usr/bin/sbcl
#| else # permits #!/usr/bin/env sbcl , but breaks sbcl --help, etc.
#|   exec /usr/bin/sbcl --script $*
#| fi
#| 
#- }}}


####FILE +x bin/machineid {{{
#| #!/bin/sh
#| 
#| # Prints machine unique string, truncated to 4 chars.
#| 
#| if [ -e /etc/machine-id ]; then
#|     if cat /etc/machine-id | grep . >/dev/null; then
#|         cat /etc/machine-id | cut -c1-4
#|     else
#|         echo 0000
#|     fi
#| else
#|     echo 0000
#| fi
#- }}}


####FILE +x bin/moshc {{{
#| #!/bin/sh
#| 
#| [ $# -ne 3 ] && { printf "Usage: moshc IP PORT KEY\nPress ctrl-a . to exit\n" >&2; exit 1; }
#| 
#| MOSH_ESCAPE_KEY=$(printf "\x01") MOSH_KEY=$3 mosh-client "$1" "$2"
#- }}}


####FILE +x bin/myprompt {{{
#| #!/bin/awk -f
#| 
#| # First argument must be "--"
#| 
#| # Performance note:
#| #    cmd | getline x    -- slow
#| #    system(cmd)        -- slow
#| #    getline x < file   -- fast
#| #    ENVIRON["var"]     -- fast
#| # 1. Use external cmd as few times as possible.
#| #    Try to combine multiple cmds.
#| # 2. Try using ENVIRON and only when it does not gives the info, call external cmd.
#| 
#| function print_help() {
#|     print "Usage: myprompt -- [options ...]"
#|     print "Options:"
#|     print "  --shell SHELL     Set shell name           (default: $SHELL)"
#|     print "  --last-status N   Last command exit code   (default: 0)"
#|     print "  --last-signal N   Last command kill signal (default: 0)"
#|     print "  --tmux            Use tmux formatting"
#|     print "  --short           Only print user@host"
#|     print "  --help            Help"
#| }
#| 
#| BEGIN {
#| 
#|     # Parse arguments
#|     argi = 1
#|     SHELL = ENVIRON["SHELL"]
#|     while (argi < ARGC) {
#|         arg = ARGV[argi++]
#|         # printf "arg[%d] = [%s]\n", argi-1, arg
#|         if      (arg == "--shell")               { SHELL      = ARGV[argi++] }
#|         else if (arg == "--last-status")         { LASTSTATUS = ARGV[argi++] }
#|         else if (arg == "--last-signal")         { LASTSIGNAL = ARGV[argi++] }
#|         else if (arg == "--tmux")                { TMUX       = 1            }
#|         else if (arg == "--short")               { SHORT      = 1            }
#|         else if (arg == "--help" || arg == "-h") { print_help(); exit        }
#|         else { printf "Invalid argument: %s\n", arg; print_help(); exit }
#|     }
#| 
#|     # Color table
#|     if (TMUX) {
#|         C[0] = C["k"] = "#[fg=black]"; C[1] = C["r"] = "#[fg=red]"
#|         C[2] = C["g"] = "#[fg=green]"; C[3] = C["y"] = "#[fg=yellow]"
#|         C[4] = C["b"] = "#[fg=blue]";  C[5] = C["m"] = "#[fg=magenta]"
#|         C[6] = C["c"] = "#[fg=cyan]";  C[7] = C["w"] = "#[fg=white]"
#|         C["bold"] = "#[bold]"; C["none"] = "#[default]"
#|     } else {
#|         C[0] = C["k"] = "\033[30m"; C[1] = C["r"] = "\033[31m"
#|         C[2] = C["g"] = "\033[32m"; C[3] = C["y"] = "\033[33m"
#|         C[4] = C["b"] = "\033[34m"; C[5] = C["m"] = "\033[35m"
#|         C[6] = C["c"] = "\033[36m"; C[7] = C["w"] = "\033[37m"
#|         C["bold"] = "\033[1m"; C["none"] = "\033[0m"
#|     }
#| 
#|     # Only print user@host and exit
#|     if (SHORT) {
#|         printf "%s%s", get_uandh(0), C["none"]
#|         exit
#|     }
#| 
#|     # Components
#|     uandh = get_uandh(1)
#|     dir   = get_dir()
#|     git   = get_git()
#|     codes = get_codes()
#|     arrow = get_arrow()
#| 
#|     # Write output
#|     output = uandh C["none"] " " C["m"] (git ? git " " : "") C["g"] dir " " C["r"] (codes ? codes " " : "") C["bold"] arrow " " C["none"]
#|     printf "%s", output # no newline
#| 
#|     # Must explicitly exit, otherwise awk waits stdin
#|     exit
#| 
#| }
#| 
#| function get_uandh(trunc,    user, host, cu, ch) {
#|     user = ENVIRON["USER"]
#| 
#|     # ENVIRON["hostname"], ENVIRON["HOSTNAME"], ENVIRON["HOST"] are not passed to awk from shell? (fish has $hostname, bash $HOSTNAME, zsh $HOST but none of them are passed. sh and elvish has neither of them)
#|     getline host < "/etc/hostname"
#|     if (!host) { "uname -n" | getline host }
#| 
#|     cu = C[hash(user, 7, 6) + 1]
#|     ch = C[hash(host, 7, 0) + 1]
#| 
#|     # abbreviate if too long
#|     if (trunc && length(user) >= 6)
#|         user = substr(user, 1, 2) "." substr(user, (length(user) - 1))
#|     if (trunc && length(host) >= 6)
#|         host = substr(host, 1, 2) "." substr(host, (length(host) - 1))
#| 
#|     # colorize (using hash) and return
#|     return cu user C["c"] "@" ch host
#| }
#| 
#| function get_dir(    pwd, i, a, n) {
#| 
#|     # get pwd
#|     pwd = ENVIRON["PWD"]
#|     if (!pwd) { "pwd" | getline pwd }
#| 
#|     # $HOME to ~
#|     if ((i = index(pwd, ENVIRON["HOME"])) == 1)
#|         pwd = "~" substr(pwd, length(ENVIRON["HOME"]) + 1)
#| 
#|     # remove trailing / (buf not if pwd is the root dir)
#|     if (substr(pwd, length(pwd)) == "/" && length(pwd) > 2)
#|         pwd = substr(pwd, 1, length(pwd) - 1)
#| 
#|     # keep only first char of each path component except the last one
#|     n = split(pwd, a, "/")
#|     for (i=1; i<n; i++)
#|         a[i] = substr(a[i], 1, match(a[i], "[^-._\\[\\]]"))
#| 
#|     # join path components
#|     pwd = a[1]
#|     for (i=2; i<=n; i++)
#|         pwd = pwd "/" a[i]
#|     return pwd
#| 
#| }
#| 
#| function get_git(    cmd, out, out2) {
#|     # checking "command -v git" and "git rev-parse --is-inside-work-tree" does not really increase performance
#|     cmd = "git rev-parse --abbrev-ref HEAD 2>/dev/null && git status -s 2>/dev/null"
#|     cmd | getline out
#|     if (out) {
#|         if (1 == (cmd | getline out2))
#|             out = out "+"
#|         return "(" out ")"
#|     }
#| }
#| 
#| function get_codes(    cmd, killsig) {
#|     if (LASTSTATUS != 0) {
#|         if (LASTSIGNAL != 0) {
#|             cmd = "kill -l " LASTSIGNAL
#|             cmd | getline killsig
#|             # For some reason, following does not work.
#|             #    "kill -l " LASTSIGNAL | getline killsig
#|             # It shows "/bin/sh: 1: 2: not found" when LASTSIGNAL is 2.
#|             killsig = "|SIG" killsig
#|         }
#|         return "[" LASTSTATUS killsig "]"
#|     }
#| }
#| 
#| function get_arrow() {
#|     if (0 != index(SHELL, "fish_private"))
#|         return C["m"] ">>>"
#|     if (0 != index(SHELL, "fish"))
#|         return C["r"] ">" C["y"] ">" (ENVIRON["RANGER_LEVEL"] ? C["g"] : C["b"]) ">"
#|     if (0 != index(SHELL, "elvish"))
#|         return C["g"] ">>" C["w"] ">"
#|     if (0 != index(SHELL, "bash"))
#|         return C["y"] ">>" C["r"] ">"
#|     return C["w"] ">>>"
#| }
#| 
#| function hash(s, n, seed,    i) {
#|     for (i=1; i<=length(s); i++)
#|         seed += ord(substr(s, i, 1))
#|     return seed % n
#| }
#| 
#| function ord(c,    i) {
#|     # perl ord() for printable ascii chars
#|     if (0 != (i = index(" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", c))) {
#|         return i + 31
#|     }
#|     return 0
#| }
#- }}}


####FILE +x bin/n {{{
#| #!/bin/bash
#| 
#| command -v nnn >/dev/null || { echo "nnn is not installed" >&2; exit 1; }
#| 
#| # rannnger: emulate ranger in nnn
#| 
#| getPreview() {
#|     local x="$1"
#|     local width="$2"
#|     local height="$3"
#|     if [[ -d "$x" ]]; then
#|         ls -1A --color "$x" | head -n "$((height - 2))" | cut -c 1-"$width"
#|     elif [[ "$(file --mime "$x")" == *charset=binary* ]]; then
#|         echo Binary
#|     else
#|         head -n "$((height - 2))" "$x" | cut -c 1-"$width"
#|     fi
#| }
#| watchPreview() {
#|     declare -A preview=()
#|     declare -A previewTime=()
#|     width=0 height=0
#|     rm "$NNN_FIFO.2" 2>/dev/null || true; mkfifo "$NNN_FIFO.2"
#|     while read -r x; do
#|         echo "$x" >&2 &
#|         mtime=$(stat -c %y "$x")
#|         width1=$(tput cols)
#|         height1=$(tput lines)
#|         if [[ "$width" != "$width1" || "$height" != "$height1" ]]; then
#|             preview=() previewTime=() width="$width1" height="$height1"
#|         fi
#|         if [[ -n "${preview["$x"]}" && "$mtime" = "${previewTime["$x"]}" ]]; then
#|             flag=CACHE
#|         else
#|             flag=NEW
#|             p=$(getPreview "$x" "$width" "$height")
#|             preview["$x"]="$p"
#|             previewTime["$x"]="$mtime"
#|         fi
#|         clear
#|         echo -ne '\e[0m'
#|         echo "$flag ${previewTime["$x"]} $x"
#|         echo "${preview["$x"]}"
#|     done < "$NNN_FIFO" 2> "$NNN_FIFO.2"
#| }
#| watchPreview2() {
#|     # while sleep 1; do date; done
#|     sleep 1
#|     while read -r x; do
#|         x=$(dirname "$x")
#|         x=$(dirname "$x")
#|         clear
#|         ls -1 --color "$x"
#|     done < "$NNN_FIFO.2"
#| }
#| export -f getPreview
#| export -f watchPreview
#| export -f watchPreview2
#| 
#| opener() {
#|     # nano "$2"
#|     tmux -L "$1" new-window nano "$2"
#| }
#| export -f opener
#| 
#| name=aaa-$$
#| fifo="/tmp/fifoaaa-$name"
#| conf="
#| # set -g default-command /bin/sh
#| set -g mouse on
#| set -g pane-border-indicators off
#| set -g pane-active-border-style 'fg=black,bg=black'
#| set -g status off
#| bind -n f6 kill-server
#| bind -n ! new-window -c '#{pane_current_path}'
#| "
#| 
#| rm "$fifo" 2>/dev/null; mkfifo "$fifo"
#| # trap 'tmux -L "$sock" kill-server; exit' INT TERM
#| #
#| export NNN_FIFO="$fifo"
#| export NNN_OPENER='bash -c opener${IFS}"'"$name"'"${IFS}"$1" --'
#| export NNN_FCOLORS=000102030405060708090a0b0c0d0e0f # TODO match ls color + video etc.
#| 
#| tmux -L "$name" -f <(echo "$conf") \
#|     new-session nnn -cdRU \; \
#|     split-window -hb -l 15% bash -c 'watchPreview2' \; \
#|     select-pane -t :.+ \; \
#|     split-window -h  bash -c 'watchPreview' \; \
#|     select-pane -t :.+ \; \
#|     select-pane -t :.+
#| rm "$fifo"
#| 
#- }}}


####FILE +x bin/nf1 {{{
#| #!/bin/sh
#| 
#| # Count number of files is current directory and subdirectories with depth 1
#| 
#| dir=${1:-.}
#| find "$dir" -maxdepth 1 -type d | while read -r d; do n=$(find "$d" | wc -l); printf "%d\t%s\n" "$n" "$d"; done | sort -n
#- }}}


####FILE +x bin/npm-info {{{
#| #!/bin/node
#| 
#| // import * as child_process from "child_process"; // rename to xxx.mjs to use es6 import
#| const child_process = require("child_process");
#| 
#| const CONFIG = { verbose: false }
#| 
#| function run(pkg) {
#|     if (CONFIG.verbose) console.log("npm view --json " + pkg);
#|     const out = child_process.spawnSync("npm", ["view", "--json", pkg]);
#|     const jso = JSON.parse(out.stdout.toString());
#|     return jso;
#| }
#| 
#| function readableSize(size) {
#|     return size < 1024 ? size : `${Math.floor(size/1024)} KiB`;
#| }
#| 
#| function makeCache(pkg) {
#|     const cache = {};
#|     function rec(pkg) {
#|         if (cache[pkg]) return;
#|         const jso = run(pkg);
#|         cache[pkg] = jso;
#|         for (let dep of Object.keys(jso.dependencies || {})) rec(dep);
#|     }
#|     rec(pkg)
#|     const jso1 = cache[pkg];
#|     const size = readableSize(Object.entries(cache).map(x => x[1].dist.unpackedSize).reduce((x, y) => x+y, 0));
#|     const deps = Object.keys(cache).join(" ");
#|     console.log("Name       :", jso1.name);
#|     console.log("Summary    :", jso1.description);
#|     console.log("Version    :", jso1.version);
#|     console.log("Uploaded   :", jso1.time.modified);
#|     console.log("URL        :", jso1.homepage);
#|     console.log("Total Size :", size);
#|     console.log("Total Deps :", deps);
#| }
#| 
#| function main() {
#|     const args = process.argv.slice(2);
#|     let pkg, help;
#|     for (let i=0; i<args.length; i++) {
#|         if (args[i] == "-v") CONFIG.verbose = true;
#|         if (args[i] == "-h" || args[i] == "--help") help = true;
#|         else pkg = args[i];
#|     }
#|     if (help || !pkg) {
#|         console.log("Usage: npm-pkginfo [-h] [-v] PACKAGE");
#|         if (!pkg) console.log("ERROR: package name not given")
#|         return;
#|     }
#|     makeCache(pkg);
#| }
#| 
#| main();
#- }}}


####FILE +x bin/nvimhl {{{
#| #!/bin/sh
#| 
#| if [ $# -ne 1 ]; then
#|     echo "Usage: nvimhl <file>    read file and write syntax-highlighted html"
#|     echo "       nvimhl -         read stdin instead of file"
#|     exit
#| fi
#| 
#| in=$1
#| 
#| cmds='
#| set number
#| set nofoldenable
#| 
#| syntax on
#| colorscheme morning
#| hi Normal ctermfg=black ctermbg=white
#| 
#| let g:html_no_progress=1
#| runtime! syntax/2html.vim
#| w! /dev/stdout
#| qa!
#| '
#| 
#| head='
#| <meta http-equiv="content-type" content="text/html; charset=utf-8">
#| <meta name="viewport" content="width=device-width, initial-scale=1">
#| <style>pre{overflow-wrap:anywhere;line-break:anywhere}.LineNr{user-select:none}</style>
#| '
#| 
#| nvim -u NONE --headless -c "$cmds" "$in" 2>/dev/null \
#|     | awk -v x="$head" '{ print } /<head>/ { print x }'
#| 
#- }}}


####FILE +x bin/oll {{{
#| #!/bin/sh
#| 
#| # call ollama api and streams response
#| 
#| for cmd in curl jq stdbuf; do
#|     command -v "$cmd" >/dev/null || { echo "Command $cmd is not available" >&2; exit 1; }
#| done
#| 
#| [ "$#" -eq 0 ] && {
#|     echo >&2 "Usage: oll HOST:PORT MODEL PROMPT ..."
#|     echo >&2 "       oll HOST:PORT list"
#|     echo >&2 "       oll reset"
#|     exit 1
#| }
#| 
#| tmpdir=$(mktemp -d -u)
#| tmpdir=${tmpdir%/*}/oll
#| mkdir -p "$tmpdir"
#| 
#| if [ "$1" = reset ]; then
#|     rm -f "$tmpdir/context"
#|     exit
#| fi
#| 
#| if [ "$2" = list ]; then
#|     curl -s "$1"/api/tags | jq -r .models[].model
#|     exit
#| fi
#| 
#| addr="$1"
#| model="$2"
#| shift 2
#| prompt="$*"
#| prompt_withquote=$(printf %s "$prompt"|jq -Rs .)
#| 
#| context=null
#| if [ -e "$tmpdir/context" ]; then
#|     read -r context < "$tmpdir/context"
#|     if ! echo "$context" | grep -qE '^\[[0-9]+(,[0-9]+)*\]$'; then context=null; fi
#|     # context is like [123,45678,...,333,44444] or null
#| fi
#| 
#| json="{
#|     \"model\"      : \"$model\",
#|     \"prompt\"     : $prompt_withquote,
#|     \"keep_alive\" : \"99999m\",
#|     \"context\"    : $context
#| }"
#| # \"options\" : { \"num_ctx\" : 65536 },
#| 
#| printf "%s\n" "$json" > "$tmpdir/request"
#| 
#| stdbuf -o0 \
#|     curl -s "http://$addr/api/generate" -d "@$tmpdir/request" \
#|     | jq -j --unbuffered 'if .context then .context|stderr|empty else .response end' \
#|     2>"$tmpdir/context" | tee "$tmpdir/response"
#| 
#| # rm "$tmpdir/request" "$tmpdir/response"
#- }}}


####FILE +x bin/passq {{{
#| #!/bin/bash
#| 
#| # All passwords in single plaintext file /all
#| # Each line "%xx.yy=pswd" means passwords ("%" must be at beginning of line)
#| # For convenience, copy into the password into file /auto/xx/yy
#| # on genauto command.
#| # Single file is flexible and easier to remember (than using directories)
#| 
#| function usage {
#|     echo "Usage:"
#|     echo "  passq show <query>  -- Show password that matches <query> in /all"
#|     echo "                         Also copy to clipboard (using xclip)"
#|     echo "  passq edit          -- Edit /all (and run passq genauto)"
#|     echo "  passq list          -- List passwords in /all"
#|     echo "  passq genauto       -- For each password in /all, store it under /auto/ directory"
#|     echo "                         (convenient with rofi pass etc.)"
#|     echo "In /all, each line of the format \"%xx.yy=pswd\" defines a password."
#|     echo "When genauto is used, this password will become /auto/xx/yy with contents pswd."
#| }
#| 
#| [ $# -eq 0 ] && { usage; exit; }
#| 
#| ## Setup parameters
#| op=$1
#| query=$2
#| 
#| ## Get "%name=text" from $1, and add /auto/name with contents text
#| function addauto {
#|     # split from while loop bacause of incorrect vim indentation.
#|     line=$1
#|     name=$(echo "$line" | sed 's/^%\([^=]*\)=\(.*\)/\1/; s/\./\//g')
#|     text=$(echo "$line" | sed 's/^%\([^=]*\)=\(.*\)/\2/')
#|     # echo -e "$name\t$text"
#|     echo -e "$text\n$text" | pass insert --force "auto/$name" >/dev/null
#| }
#| 
#| ## Copy stdin to clipboard (will not output to stdout)
#| has_xclip=$(command -v xclip >/dev/null && echo y || echo n)
#| function clipboard_copy {
#|     if [ "$has_xclip" = y ]; then
#|         xclip -selection clipboard -i
#|     else
#|         cat >/dev/null
#|     fi
#| }
#| 
#| ## genauto (update auto/*)
#| function genauto {
#|     echo "Cleaning /auto/* ..."
#|     pass rm -r --force auto >/dev/null
#|     echo "Generating /auto/* ..."
#|     pass show all | sed "/^%/!d" | while read line; do addauto "$line"; done
#| }
#| 
#| ## Main
#| case "$op" in
#|     show)    pass show all | sed "/^%$query/!d; s/^[^=]*=//" | tee /dev/stderr | clipboard_copy ;;
#|     edit)    pass edit all; genauto ;;
#|     list)    pass show all | sed "/^%/!d" ;;
#|     genauto) genauto ;;
#|     *) echo "Unknown operation: $op" ; usage ;;
#| esac
#| 
#- }}}


####FILE +x bin/ping-scan {{{
#| #!/bin/sh
#| 
#| # vim set noinf
#| 
#| [ $# -eq 0 ] && { echo "Usage: $0 PREFIX [TIMEOUT]"; echo "example: $0 192.168.1 3"; exit 1; }
#| 
#| pfx=${1:-192.168.1}
#| tout=${2:-5}
#| 
#| tmpd=$(mktemp -d /tmp/ping-scan-XXXXXXX)
#| 
#| pids=""
#| for i in $(seq 1 254); do
#|     ip=$pfx.$i
#|     sh -c "timeout $tout ping -c1 $ip && touch \"$tmpd\"/$ip || rm \"$tmpd\"/$ip" >/dev/null 2>&1 &
#|     pids="$pids $!"
#| done
#| wait $pids
#| 
#| ls "$tmpd"
#| rm -r "$tmpd"
#- }}}


####FILE +x bin/pip-info {{{
#| #!/usr/bin/env python3
#| import argparse, json, os, os.path, platform, re, sys, time, urllib.error, urllib.request
#| 
#| CONFIG = { "verbose": False }
#| 
#| # TODO recursive dependencies
#| 
#| def parseSpec(spec):
#|     m = re.match(r"([-.\w]+)(\[([-.\w]+)\])?", spec)
#|     name = m[1]
#|     extra = m[3]
#|     expr = spec.split(";")[1].strip() if ";" in spec else "True" # Empty spec => always required
#|     return { "spec": spec, "name": name, "extra": extra, "expr": expr }
#| 
#| # print(parseSpec("urllib3"))
#| # print(parseSpec("urllib3[secure]"))
#| # print(parseSpec("botocore[crt] (<2.0a0,>=1.21.0) ; extra == 'crt'"))
#| # exit()
#| 
#| dlCacheEnabled = False
#| dlCacheDir     = "__pdp_cache"
#| dlCache        = {}
#| if dlCacheEnabled:
#|     if not os.path.exists(dlCacheDir):
#|         os.mkdir(dlCacheDir)
#|     for f1 in os.listdir(dlCacheDir):
#|         with open(f"{dlCacheDir}/{f1}") as f:
#|             dlCache[f1[:-5]] = json.load(f)
#| def dl(name):
#|     if name in dlCache:
#|         return dlCache[name]
#|     url = f"https://pypi.org/pypi/{name}/json"
#|     req = urllib.request.Request(url)
#|     try:
#|         if CONFIG["verbose"]: print(f"Downloading {url}")
#|         res = urllib.request.urlopen(req)
#|     except urllib.error.HTTPError:
#|         print("No such package:", name, file=sys.stderr)
#|         return {}
#|     dat = res.read().decode("utf-8")
#|     jso = json.loads(dat)
#|     dlCache[name] = jso
#|     if dlCacheEnabled:
#|         with open(f"{dlCacheDir}/{name}.json", "w") as f:
#|             f.write(dat)
#|     return jso
#| 
#| def get_implementation_version():
#|     def format_full_version(info):
#|         version = '{0.major}.{0.minor}.{0.micro}'.format(info)
#|         kind = info.releaselevel
#|         if kind != 'final':
#|             version += kind[0] + str(info.serial)
#|         return version
#| 
#|     if hasattr(sys, 'implementation'):
#|         return format_full_version(sys.implementation.version)
#|     else:
#|         return "0"
#| 
#| def rec(spec):
#|     pkg = parseSpec(spec)
#|     jso = dl(pkg["name"])
#| 
#|     if not jso: return []
#|     # json.dump(jso, open(f"debug-{pkg['name']}.json", "w"), indent=2)
#| 
#|     # See https://peps.python.org/pep-0508/
#|     g = {
#|         "os_name":                        os.name,
#|         "sys_platform":                   sys.platform,
#|         "platform_machine":               platform.machine(),
#|         "platform_python_implementation": platform.python_implementation(),
#|         "platform_release":               platform.release(),
#|         "platform_system":                platform.system(),
#|         "platform_version":               platform.version(),
#|         "python_version":                 '.'.join(platform.python_version_tuple()[:2]),
#|         "python_full_version":            platform.python_version(),
#|         "implementation_name":            sys.implementation.name,
#|         "implementation_version":         get_implementation_version(),
#|         "extra":                          pkg["extra"],
#|     }
#|     depSpecs = jso["info"]["requires_dist"] or []
#|     parsedSpecs = map(parseSpec, depSpecs)
#|     deps = [
#|         parsedSpec for parsedSpec in parsedSpecs
#|         if eval(parsedSpec["expr"], g)
#|     ]
#|     # deps = filter(lambda x: eval(x["expr"], g), map(parseSpec, depSpecs))
#| 
#|     return sum([rec(dep["spec"]) for dep in deps], [pkg["name"]])
#| 
#| def main(args):
#|     CONFIG["verbose"] = args.verbose
#| 
#|     spec = args.pkg
#|     pkg = parseSpec(spec)
#|     dic = dict(dl(pkg["name"]))
#| 
#|     deps = sorted(list(set(rec(spec))))
#|     size = sum([dl(x)["urls"][0]["size"] for x in deps if len(dl(x)["urls"]) > 0])
#| 
#|     dic["info"]["total_deps"] = deps
#|     dic["info"]["total_size"] = size
#| 
#|     sizeTxt = size if size < 1024 else (f"{size//1024} KiB" if size < 1024**2 else f"{size//(1024**2)} MiB")
#| 
#|     if args.json:
#|         json.dump(dic, sys.stdout)
#|     else:
#|         print("Name       :", spec)
#|         print("Summary    :", dic["info"]["summary"])
#|         print("Version    :", dic["info"]["version"])
#|         print("Uploaded   :", dic["releases"][dic["info"]["version"]][0]["upload_time"].replace("T", " "))
#|         print("URL        :", dic["info"]["project_url"])
#|         print("Total Size :", sizeTxt)
#|         print("Total Deps :", " ".join(deps))
#| 
#| if __name__ == "__main__":
#|     ap = argparse.ArgumentParser()
#|     ap.add_argument("-j", "--json", action="store_true")
#|     ap.add_argument("-v", "--verbose", action="store_true")
#|     ap.add_argument("pkg")
#|     args = ap.parse_args()
#|     main(args)
#- }}}


####FILE +x bin/py {{{
#| #!/bin/sh
#| 
#| code="\
#| from (math) import *
#| import (json), (os), (re), (time)
#| import collections as (co); import datetime as (dt); import functools as (ft); import itertools as (it)
#| import urllib.parse as (up); import urllib.request as (ur)"
#| 
#| printf "$(printf %s "$code" | sed 's/(/\\033[31m/g; s/)/\\033[0m/g')\n"
#| 
#| command -v python3 >/dev/null && PYTHON=python3 || PYTHON=python
#| exec "$PYTHON" -ic "$(printf %s "$code" | sed 's/[()]//g')" "$@"
#- }}}


####FILE +x bin/py-jq {{{
#| #!/usr/bin/env python3
#| 
#| # Simple version of jq and gron
#| 
#| import argparse, json, re, sys
#| 
#| def tolist(x):
#|     if type(x) is dict: return list(x.values())
#|     elif type(x) is list: return x
#|     else: raise Exception("err")
#| 
#| def jq(lis, query):
#|     # lis = list(lis); print(lis, query) # generators can be consumed at most once
#|     rkey = r"[^][.]+"
#|     rnum = r"[0-9]+"
#|     if query == "." or query == "": # .
#|         return list(lis)
#|     elif m := re.match(rf"\.({rkey})", query): # .key
#|         return jq((x[m[1]] for x in lis), query[m.end():])
#|     elif m := re.match(rf"\.?\[\]", query): # .[]
#|         return jq(sum((tolist(x) for x in lis), []), query[m.end():])
#|     elif m := re.match(rf"\.?\[({rnum})\]", query): # .[0]
#|         return jq((x[int(m[1])] for x in lis), query[m.end():])
#|     assert False
#| 
#| # should name above "jqm" and create wrapper "jq" which handles multiple inputs
#| 
#| def gron(jso, compact, raw):
#|     result = []
#|     def push(left, right): result.append(f"{left}={right}" if compact else f"{left} = {right};")
#|     def gron(jso, prefix="json"):
#|         if type(jso) is dict:
#|             push(prefix, "{}")
#|             for k, v in jso.items(): gron(v, f"{prefix}.{k}")
#|         elif type(jso) is list:
#|             push(prefix, "[]")
#|             for i, v in enumerate(jso): gron(v, f"{prefix}[{i}]")
#|         else:
#|             push(prefix, jso if raw else json.dumps(jso, separators=(',', ':')))
#|     gron(jso)
#|     return result
#| 
#| def _test():
#|     jso = { "a": { "a1": 10 }, "b": [ 20, "21", 22, "23" ], "c": { "c1": [31, 32], "c2": [33, 34] } }
#|     from subprocess import run
#|     def t1(i, x, y): print(i, x==y, x, "" if x==y else y)
#|     def t2(i, lis, query):
#|         x = jq(lis, query)
#|         y = json.loads(run(["jq", "[" + query + "]"], input="\n".join(json.dumps(x) for x in lis).encode(), capture_output=True).stdout.decode())
#|         t1(i, x, y)
#|     t2(1,  [jso], ".")
#|     t2(2,  [jso], ".a")
#|     t2(3,  [jso], ".b")
#|     t2(4,  [jso], ".[]")
#|     t2(5,  [jso], ".b[]")
#|     t2(6,  [jso], ".c.c2[1]")
#|     t2(7,  [jso], ".c[][1]")
#|     t1(31, gron(jso, False, False), [ 'json = {};', 'json.a = {};', 'json.a.a1 = 10;', 'json.b = [];', 'json.b[0] = 20;', 'json.b[1] = "21";', 'json.b[2] = 22;', 'json.b[3] = "23";', 'json.c = {};', 'json.c.c1 = [];', 'json.c.c1[0] = 31;', 'json.c.c1[1] = 32;', 'json.c.c2 = [];', 'json.c.c2[0] = 33;', 'json.c.c2[1] = 34;' ])
#|     t1(32, gron(jso, True, False), [ 'json={}', 'json.a={}', 'json.a.a1=10', 'json.b=[]', 'json.b[0]=20', 'json.b[1]="21"', 'json.b[2]=22', 'json.b[3]="23"', 'json.c={}', 'json.c.c1=[]', 'json.c.c1[0]=31', 'json.c.c1[1]=32', 'json.c.c2=[]', 'json.c.c2[0]=33', 'json.c.c2[1]=34' ])
#|     t1(33, gron(jso, True, True), [ 'json={}', 'json.a={}', 'json.a.a1=10', 'json.b=[]', 'json.b[0]=20', 'json.b[1]=21', 'json.b[2]=22', 'json.b[3]=23', 'json.c={}', 'json.c.c1=[]', 'json.c.c1[0]=31', 'json.c.c1[1]=32', 'json.c.c2=[]', 'json.c.c2[0]=33', 'json.c.c2[1]=34' ])
#| 
#| if __name__ == "__main__":
#|     ap = argparse.ArgumentParser(description="Simple version of jq and gron")
#|     ap.add_argument("-c", "--compact", action="store_true")
#|     ap.add_argument("-g", "--gron",    action="store_true")
#|     ap.add_argument("-r", "--raw",     action="store_true")
#|     ap.add_argument("--test",          action="store_true")
#|     ap.add_argument("query", nargs="?")
#|     args = ap.parse_args()
#|     if args.test:
#|         _test()
#|     elif args.gron:
#|         lis = gron(json.load(sys.stdin), args.compact, args.raw)
#|         for x in lis:
#|             print(x)
#|     else:
#|         if not args.query:
#|             ap.print_help()
#|             print("ERROR: Query required", file=sys.stderr)
#|             exit(1)
#|         lis = jq([json.load(sys.stdin)], args.query)
#|         for jso in lis:
#|             if args.raw and type(jso) is str:
#|                 print(jso)
#|             elif args.compact:
#|                 print(json.dumps(jso, ensure_ascii=False, separators=(',', ':')))
#|             else:
#|                 print(json.dumps(jso, ensure_ascii=False, indent=2))
#- }}}


####FILE +x bin/q {{{
#| #!/bin/sh
#| 
#| [ $# -le 0 ] && { echo "Usage: ./quiet COMMAND ARGS ..."; exit 1; }
#| 
#| "$@" >/dev/null 2>&1 &
#| 
#| # recommended fish config (complete commands):
#| # complete -c q -xa '(__fish_complete_subcommand)'
#- }}}


####FILE +x bin/quiet {{{
#| #!/bin/sh
#| 
#| [ $# -le 0 ] && { echo "Usage: ./quiet COMMAND ARGS ..."; exit 1; }
#| 
#| "$@" >/dev/null 2>/dev/null
#- }}}


####FILE +x bin/randomstr {{{
#| #!/bin/bash
#| 
#| usage() {
#|     echo "Usage: randomstr [-n] <length> <spec>"
#|     echo "  Get a random string of length <length> using characters specified by <spec>,"
#|     echo "  and copy the string to clipboard using xclip if available."
#|     echo
#|     echo "   -n    don't copy to clipboard"
#|     echo
#|     echo "  <spec> is a string of following characters. (default ad)"
#|     echo "    a/A: small/capital alphabets"
#|     echo "    d:   digits (0-9)"
#|     echo "    w:   shortcut for aAd_"
#|     echo "    _:   underscore"
#|     echo "    -:   some symbols:  !\"#\$%&()*+,-./:;<=>?@[]^_\`{|}~"
#| }
#| 
#| if [ $# -eq 0 ]; then usage; exit 0; fi
#| 
#| nflag=0
#| if [ "$1" = -n ]; then nflag=1; shift; fi
#| 
#| len=$1
#| [ $# -eq 1 ] && options=xad || options=x$2
#| [ "$options" = xw ] && options=xaAd_
#| 
#| charset=""
#| 
#| [ $options != ${options//a/} ] && charset=${charset}a-z
#| [ $options != ${options//A/} ] && charset=${charset}A-Z
#| [ $options != ${options//d/} ] && charset=${charset}0-9
#| [ $options != ${options//_/} ] && charset=${charset}_
#| [ $options != ${options//-/} ] && charset=${charset}'!"#$%&()*+,-./:;<=>?@[\]^_`{|}~'
#| 
#| if [ -z "$charset" ]; then echo "Invalid spec."; usage; exit 0; fi
#| 
#| rnd=$(tr -dc "$charset" </dev/urandom | head -c $len ; echo '')
#| 
#| echo $rnd
#| 
#| if [ $nflag -eq 0 ] && command -v xclip > /dev/null; then
#|     echo -n $rnd | xclip -i -selection clipboard
#| fi
#| 
#| # #!/bin/bash
#| 
#| # # Needs bash for regexp comparison
#| 
#| # if [ $# -ne 1 -a $# -ne 2 ]; then
#| #   echo "Usage: randomstr <length> <spec>"
#| #   echo "  Get a random string of length <length> using characters specified by <spec>,"
#| #   echo "  and copy the string to clipboard using xclip if available."
#| #   echo "  <spec> is a string of following characters. (default ad)"
#| #   echo "    a/A: small/capital alphabets"
#| #   echo "    d:   digits (0-9)"
#| #   echo "    w:   shortcut for aAd_"
#| #   echo "    _/-: underscore and hyphen, literally"
#| #   exit 0
#| # fi
#| 
#| # len=$1
#| # [ $# -eq 1 ] && options=ad || options=$2
#| 
#| # box=()
#| 
#| # [[ $options =~ a || $options =~ w ]] && box+=(a b c d e f g h i j k l m n o p q r s t u v w x y z)
#| # [[ $options =~ A || $options =~ w ]] && box+=(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z)
#| # [[ $options =~ d || $options =~ w ]] && box+=(0 1 2 3 4 5 6 7 8 9)
#| # [[ $options =~ _ || $options =~ w ]] && box+=(_)
#| # [[ $options =~ '-' ]]                && box+=('-')
#| 
#| # i=0
#| # while [ $i -lt $len ]; do
#| #   rnd="$rnd$(shuf -e -n 1 ${box[@]})"
#| #   i=$(expr $i + 1)
#| # done
#| 
#| # echo $rnd
#| 
#| # if command -v xclip > /dev/null; then
#| #   echo -n $rnd | xclip -i -selection clipboard
#| # fi
#- }}}


####FILE +x bin/recentfile {{{
#| #!/bin/sh
#| 
#| # Get the N most recently modified file in the current directory
#| 
#| N="$1"
#| [ -z "$1" ] && N=10
#| 
#| find . -printf "%T+\t%p\n" | sort -r | head -n $N
#- }}}


####FILE +x bin/rsync2 {{{
#| #!/bin/bash
#| 
#| set -euo pipefail
#| 
#| die() { help >&2; echo >&2; echo "ERROR: $*" >&2; exit 1; }
#| echoB() { echo -ne "\033[1m"; echo "$@"; echo -ne "\033[0m"; }
#| 
#| help() {
#|     echo "Usage: $0 FROM TO [RSYNC OPTIONS ...]"
#|     echo "Note: Invoked by moving to FROM and rsync . TO"
#|     echo
#|     echo "* Exclude pattern are interpreted relative to FROM dir"
#|     echo "  - trailing slash   = match directories only"
#|     echo "  - leading slash    = path relative to FROM dir"
#|     echo "  - no leading slash = match any path component (not substring match)"
#|     echo
#|     echo "Examples:"
#|     echo "1. Use --link-dest (incremental backup)"
#|     echo "   rsync2 /path/to/mydir /dest/mydir/20230501 --link-dest=/dest/mydir/20230401 -i"
#| }
#| 
#| from=
#| to=
#| # shellcheck disable=SC2054
#| opts=(
#|     -aP # --archive --partial
#|     -H # --hard-links (hard linked two files in source will not be duplicated in the destination)
#|     # -AX # --progress --acls --xattrs
#|     --info=stats2,progress2 -h # --human-readable
#|     --log-file="$(pwd)/rsync-$(date +"%Y%m%d-%H%M%S").log"
#|     --mkpath # link mkdir -p for TO
#|     --exclude=/.cache/
#|     --exclude=/.cargo/
#|     --exclude=/.cpan/
#|     --exclude=/.go/
#|     --exclude=/.ipfs/
#|     --exclude=/.npm/
#|     --exclude=.gradle/
#|     --exclude=.venv/
#|     --exclude=node_modules/
#| )
#| 
#| # Parse args
#| [ $# -ge 2 ] || die "Not enough arguments"
#| from=$1
#| to=$2
#| shift 2
#| while [[ $# -ge 1 ]]; do
#|     case "$1" in
#|         (*) opts+=("$1"); shift ;;
#|     esac
#| done
#| 
#| # Make dest dir
#| mkdir -p "$to"
#| 
#| # To absolute path
#| from=$(cd "$from"; pwd)
#| to=$(cd "$to"; pwd)
#| 
#| # Check args
#| [[ "${from%/}" == "$from" ]] || die "$from ends with /"
#| [[ "${to%/}" == "$to" ]] || die "$to ends with /"
#| [[ -d "$from" ]] || die "$from is not a directory"
#| [[ -d "$to" ]] || die "could not create directory $to"
#| 
#| # Cd to FROM dir
#| cd "$from" || die "Cannot cd to $from"
#| echoB "Directory:"
#| echo "  $from"
#| echo
#| 
#| # Construct rsync command
#| cmd=(
#|     rsync
#|     "${opts[@]}"
#|     . "$to"
#| )
#| 
#| # Show command
#| echoB "Command:"
#| for i in "${cmd[@]}"; do
#|     printf "  %q\n" "$i"
#| done
#| 
#| # Run command
#| echo
#| echoB -n "Run this command? [y/n] "; read -r ans
#| [[ "$ans" == y ]] || die "cancelled by user"
#| # echo "${cmd[*]}"
#| "${cmd[@]}"
#- }}}


####FILE +x bin/running {{{
#| #!/bin/sh
#| 
#| foundprocs=$(ps alx | grep "$1" | grep -v grep | grep -v "$0")
#| [ -n "$foundprocs" ] && exit 0 || exit 1
#| # note: 0=true 1=false
#- }}}


####FILE +x bin/sc1 {{{
#| #!/bin/sh
#| 
#| scimrc=''
#| 
#| [ "$MYKBD" = colemakdh ] && scimrc="$scimrc"'
#| nnoremap "k" "h"
#| nnoremap "n" "j"
#| nnoremap "e" "k"
#| nnoremap "i" "l"
#| nnoremap "a" "e"
#| nnoremap "A" "E"
#| '
#| 
#| tmpdir=$(mktemp -d)
#| mkdir -p "$tmpdir/sc-im"
#| export XDG_CONFIG_HOME="$tmpdir"
#| echo "$scimrc" > "$tmpdir/sc-im/scimrc"
#| sc-im "$@"
#| rm    "$tmpdir/sc-im/scimrc"
#| rmdir "$tmpdir/sc-im/"
#| rmdir "$tmpdir/"
#- }}}


####FILE +x bin/scm {{{
#| #!/bin/bash
#| 
#| # Set NO_RLWRAP to run without rlwrap
#| 
#| libs_small=(
#|     # R7RS small (except scheme.r5rs)
#|     # These are automatically loaded when invoking "gosh -r7" interactively.
#|     base case-lambda char complex cxr eval file inexact lazy load
#|     process-context read repl time write
#| )
#| 
#| libs_srfi=(
#|     # R7RS large
#|     1   # list
#|     114 # comparator (or 128)
#|     125 # hash-table
#|     132 # sort
#|     133 # vector
#|     151 # bitwise
#| 
#|     # Others
#|     2   # and-let*
#|     8   # receive
#|     26  # cut
#|     42  # eager comprehension
#|     152 # string
#|     # 159 or 166 # combinator formatting
#| )
#| 
#| importstr="(import"
#| for l in "${libs_small[@]}"; do importstr+=" (scheme $l)"; done
#| for l in "${libs_srfi[@]}"; do importstr+=" (srfi $l)"; done
#| importstr+=")"
#| 
#| if [ -n "$NO_RLWRAP" ]; then
#|     gosh -fno-read-edit -r7 -e "$importstr" "$@"
#| else
#|     rlwrap -M .scm -q '"' -b "'"'(){}[].,#@;|`"' -pgreen \
#|         gosh -fno-read-edit -r7 -e "$importstr" "$@"
#| fi
#- }}}


####FILE +x bin/termux-my-config {{{
#| #!/bin/sh
#| command -v termux-reload-settings || { echo "termux-reload-settings is not available"; exit 1; }
#| [ -z "$1" ] && color=light || color=dark
#| [ -z "$1" ] && echo "Using light mode. Use 'termux-my-config 1' for dark mode"
#| COLORFILE=~/.termux/colors.properties
#| PROPFILE=~/.termux/termux.properties
#| [ -e "$COLORFILE" ] && { cp "$COLORFILE" "$COLORFILE.$(date +%s)"; }
#| [ -e "$PROPFILE" ] && { cp "$PROPFILE" "$PROPFILE$(date +%s)"; }
#| if [ "$color" = light ]; then
#|     {
#|         echo "foreground=#000"
#|         echo "background=#fff"
#|         echo "cursor=#722"
#|         echo
#|         echo "color0=#e8e6e4"
#|         echo "color1=#ef5253"
#|         echo "color2=#5ca824"
#|         echo "color3=#c49500"
#|         echo "color4=#33b5e1"
#|         echo "color5=#a363d5"
#|         echo "color6=#32ab90"
#|         echo "color7=#18262f"
#|         echo
#|         echo "color8=#b6bfc8"
#|         echo "color9=#ff6263"
#|         echo "color10=#6cb834"
#|         echo "color11=#d4a50c"
#|         echo "color12=#23a5d1"
#|         echo "color13=#b373d5"
#|         echo "color14=#42bba0"
#|         echo "color15=#78868f"
#|     } > "$COLORFILE"
#| else
#|     {
#|         echo "foreground=#D0D0D0"
#|         echo "background=#151515"
#|         echo "cursor=#ffcccc"
#|         echo
#|         echo "color0=#18262f"
#|         echo "color1=#ef5253"
#|         echo "color2=#7cc844"
#|         echo "color3=#e4b51c"
#|         echo "color4=#33b5e1"
#|         echo "color5=#a363d5"
#|         echo "color6=#52cbb0"
#|         echo "color7=#a6afb8"
#|         echo
#|         echo "color8=#78868f"
#|         echo "color9=#ff6263"
#|         echo "color10=#8cd854"
#|         echo "color11=#f4c52c"
#|         echo "color12=#43c5f1"
#|         echo "color13=#b373d5"
#|         echo "color14=#62dbc0"
#|         echo "color15=#b6bfc8"
#|     } > "$COLORFILE"
#| fi
#| {
#|     echo "# vibrate, beep, ignore"
#|     echo "bell-character=ignore"
#|     echo
#|     echo "# back, escape"
#|     echo "back-key=back"
#|     echo
#|     echo "extra-keys = [ \\"
#|     echo " ['ESC', '~', '/',    '|',   '{', '}', 'HOME', 'UP',   'END'  ], \\"
#|     echo " ['TAB', '>', 'CTRL', 'ALT', '[', ']', 'LEFT', 'DOWN', 'RIGHT']  \\"
#|     echo "]"
#| } > "$PROPFILE"
#| termux-reload-settings
#| 
#- }}}


####FILE +x bin/termux-url-opener {{{
#| #!/data/data/com.termux/files/usr/bin/sh
#| 
#| in=$1
#| out=$in
#| out=$(echo "$out" | sed 's/https:..www.google.com.url.q=\([^&]*\).*/\1/')
#| out=$(echo "$out" | sed 's/www.reddit.com/teddit.net/')
#| out=$(echo "$out" | sed 's/old.reddit.com/teddit.net/')
#| out=$(echo "$out" | sed 's/\(mobile.\)*twitter.com/nitter.pussthecat.org/')
#| #[ "$in" = "$out" ] && out='https://en.m.wiktionary.org/w/index.php?search='"$in"
#| echo "IN:  $in"  >> ~/openlog.txt
#| echo "OUT: $out" >> ~/openlog.txt
#| termux-open-url "$out"
#- }}}


####FILE +x bin/tmux-comp {{{
#| #!/bin/sh
#| 
#| info=$(tmux display -pF 'pane_id=#{pane_id}:pane_left=#{pane_left}:pane_top=#{pane_top}:cursor_x=#{cursor_x}:cursor_y=#{cursor_y}:client_height=#{client_height}')
#| tmp=${info#*pane_id=};       t=${tmp%%:*}
#| tmp=${info#*pane_left=};     px=${tmp%%:*}
#| tmp=${info#*pane_top=};      py=${tmp%%:*}
#| tmp=${info#*cursor_x=};      cx=${tmp%%:*}
#| tmp=${info#*cursor_y=};      cy=${tmp%%:*}
#| tmp=${info#*client_height=}; h=${tmp%%:*}
#| 
#| export q
#| q=$(tmux capturep -J -p -S "$cy" -E "$cy" | cut -c-"$cx" | grep -oE '\w+$' || echo)
#| 
#| # get words matching either of those regex (matched by grep -E)
#| p1='[[:alnum:]]{4,}'
#| p2='[-+@._[:alnum:]]{4,}'
#| p3='[-+@._/:[:alnum:]]{4,}'
#| 
#| cs="tmux "
#| for i in $(tmux lsp -a -F '#D'); do cs="$cs capturep -J -pt $i \; "; done
#| # cs="$cs | grep -oE '\w{4,}' | awk -v q=\"\$q\" 'substr(\$0,1,length(q))==q{print}' | sort -u"
#| # cs="$cs | { { { tee /dev/fd/3 | grep -oE '$p1' >&4; } 3>&1 | grep -oE '$p2'; } 4>&1; } | awk -v q=\"\$q\" 'substr(\$0,1,length(q))==q{print}' | sort -u"
#| cs="$cs | { { { { tee /dev/fd/4 /dev/fd/5 | grep -oE '$p1' >&3; } 4>&1 | grep -oE '$p2' >&3; } 5>&1 | grep -oE '$p3' >&3; } 3>&1; } | awk -v q=\"\$q\" 'substr(\$0,1,length(q))==q{print}' | sort -u"
#| 
#| if ! command -v fzf >/dev/null; then
#|     s=$(eval "$cs" | head -n $((h - 2)) | awk -v q="$q" -v l="${#q}" "{a=\$0; printf \"'%s' '%c' '\", a, NR+47+(NR>10)*39-(NR>36)*58; if (l) { printf \"send -N %d BSpace ; \", l } printf \"send -l \\\"%s\\\"' \", a}")
#|     eval tmux menu "$s"
#|     exit
#| fi
#| 
#| cmd='
#|   s=$(eval "$cs" | fzf --no-color --color bw --info hidden --prompt "  " --pointer " " --print-query -q "$q")
#|   [ $? -ne 130 ] && { s=$(echo "$s" | tail -n1); tmux ${q:+send -t "$t" -N "${#q}" BSpace \;} send -t "$t" -l "$s " 2>/dev/null; }
#|   exit 0'
#| tmux popup -EB -e "cs=$cs" -e "t=$t" -e "q=$q" -w 35 -h 8 -x $(expr $px + $cx - "${#q}" - 2) -y $(expr $py + $cy + 1) "$cmd" \
#|     || tmux splitw -e "cs=$cs" -e "t=$t" -e "q=$q" -l 8 "$cmd"
#- }}}


####FILE +x bin/w3 {{{
#| #!/bin/sh
#| 
#| # Can view pdf
#| # Set sxiv for image view
#| # Help page (at search.html?, set homepage as search.html, add it to bookmark)
#| 
#| # raw w3m and w3mman command doesn't allow mouse
#| # so set TERM
#| 
#| arg1=$1
#| 
#| export WWW_HOME=~/.w3m/search.html
#| export TERM=xterm
#| 
#| [ "$MYKBD" = colemakdh ] && keymap_file=keymap_colemakdh || keymap_file=keymap_qwerty
#| conf="-o keymap_file=$keymap_file"
#| 
#| case "$arg1" in
#|     __W3_MAN__)   shift; w3mman "$@" ;; # omitting $conf (not very correct)
#|     __W3_PAGER__) shift; w3m $conf "$@" ;;
#|     localhost:*)  shift; w3m $conf "$@" "http://$arg1" ;;
#|     *.pdf)
#|         command -v ls >/dev/null || { echo "pdftohtml not available!"; exit 1; }
#|         shift
#|         pdftohtml -q -s -i -p -stdout "$arg1" | w3m $conf -T text/html "$@" -
#|         ;;
#|     *) w3m $conf "$@" ~/.w3m/search.html ;;
#| esac
#- }}}


####FILE +x bin/w3_man {{{
#| #!/bin/sh
#| 
#| w3 __W3_MAN__ "$@"
#- }}}


####FILE +x bin/w3_pager {{{
#| #!/bin/sh
#| 
#| w3 __W3_PAGER__ "$@"
#- }}}


####FILE +x bin/ww {{{
#| #!/bin/bash
#| 
#| shopt -s nullglob
#| 
#| help() {
#|     echo "Usage: ww [option ...] FILE ... -- CMD ..."
#|     echo "       cmd1 | ww [option ...] -- CMD ..."
#|     echo "Watch FILEs and run CMD on change."
#|     echo "In the second form, read paths of FILEs from stdin."
#|     echo "Similar to entr http://eradman.com/entrproject/"
#|     echo
#|     echo "Options:"
#|     echo "   -h         Help"
#|     echo "   -g         Interpret each FILE as bash glob pattern and dynamically update the list of files to watch."
#|     echo "   -t SEC     Check file update on each SEC seconds (default: 1)"
#|     echo "   -z         Exit after cmd exits"
#|     echo "   -R         Disable reloading of persistent child processes"
#|     echo "   -T         Disable showing timestamp when cmd runs"
#| }
#| 
#| 
#| 
#| # Re-expand glob patterns
#| 
#| redo_globs() {
#|     # Accept globs as arguments and store result in the variable "files"
#|     files=()
#|     while [[ $# -ge 1 ]]; do
#|         files+=($1) # this is ok if there is a glob-matching file with spaces
#|         shift
#|     done
#| }
#| 
#| 
#| 
#| ## Parse opts (TODO -- flag (option separator))
#| 
#| [[ $# -eq 0 ]] && { help; exit; }
#| gflag="" Rflag="" tval=1 Tflag="" zflag=""
#| files=()
#| globs=()
#| while true; do
#|     case "$1" in
#|         -h|--help) help; exit;;
#|         -g) gflag=1;   shift;;
#|         -R) Rflag=1;   shift;;
#|         -t) tval="$2"; shift; shift;;
#|         -T) Tflag=1;   shift;;
#|         -z) zflag=1;   shift;;
#|         --) shift; break;;
#|         *) [[ $gflag ]] && globs+=("$1") || files+=("$1"); shift;;
#|     esac
#| done
#| [ ! -t 0 ] && { while read -r f; do files+=("$f"); done; }
#| [[ $# -eq 0 ]] && { echo "ERR: No command" >&2; help; exit 1; }
#| [[ "${#files[@]}" -eq 0 ]] && [[ "${#globs[@]}" -eq 0 ]] && { echo "ERR: No files"   >&2; help; exit 1; }
#| # echo "R=$Rflag,t=$tval,T=$Tflag,z=$zflag"; echo "files: ${files[*]}"; echo "globs: ${globs[*]}"; echo "cmd: $*"
#| # exit
#| 
#| 
#| 
#| ## Misc
#| 
#| timestamp() { echo; date; }
#| 
#| trap ctrl_c INT TERM
#| ctrl_c() {
#|     # ensure kill background process, and exit successfully
#|     [[ -n "$pid" ]] && kill "$pid" 2>/dev/null
#|     exit 0
#| }
#| 
#| 
#| 
#| ## Main program
#| 
#| time=0
#| 
#| while true; do
#| 
#|     # get newest mtime of files
#|     [[ $gflag ]] && redo_globs "${globs[@]}"
#| 
#|     # (skip if glob expands to zero files)
#|     if [[ "${#files[@]}" -ge 1 ]]; then
#| 
#|         newtime=$(stat -c %Y "${files[@]}" | sort -n | tail -n 1)
#| 
#|         if [[ "$time" != "$newtime" ]]; then
#| 
#|             # (unless -R flag) kill persistent process
#|             [[ -z $Rflag ]] && [[ -n "$pid" ]] && { kill "$pid" 2>/dev/null; }
#| 
#|             # (unless -T flag) show timestamp
#|             [[ -z $Tflag ]] && timestamp
#| 
#|             # run command and save pid
#|             "$@" &
#|             pid=$!
#| 
#|             # (-z flag) wait after cmd exits
#|             [[ $zflag ]] && { wait "$pid" && exit 0; }
#| 
#|             # update timestamp data
#|             time=$newtime
#| 
#|         fi
#| 
#|     fi
#| 
#|     sleep "$tval"
#| 
#| done
#| 
#| # ex.
#| # ww -g '*.txt' -- date
#| # # this prints datetime on (1) change in existing .txt file (2) new .txt file added (3) .txt file removed.
#- }}}


####FILE +x bin/x-autorotate {{{
#| #!/bin/sh
#| 
#| # requires iio-sensor-proxy
#| 
#| pkill -x monitor-sensor
#| monitor-sensor --accel | while read -r x; do
#|     t=
#|     case "${x##* }" in
#|         (normal)    t=0   ;;
#|         (right-up)  t=90  ;;
#|         (bottom-up) t=180 ;;
#|         (left-up)   t=270 ;;
#|     esac
#|     [ -n "$t" ] && swaymsg output DSI-1 transform "$t"
#| done
#- }}}


####FILE +x bin/x-brightness {{{
#| #!/bin/sh
#| 
#| for dir in /sys/class/backlight/backlight /sys/class/backlight/intel_backlight; do
#|     [ -d "$dir" ] && break
#| done
#| brightness_file=$dir/brightness
#| max_brightness_file=$dir/max_brightness
#| 
#| help() {
#|     echo "Usage: $0 <brightness>" >&2
#|     echo "<brightness> = 1, +2, -2 etc. Max $(cat $max_brightness_file)" >&2
#|     echo 'You should add the following line to /etc/sudoers (via "sudo visudo")' >&2
#|     echo "  ALL ALL=(ALL) NOPASSWD: /usr/bin/tee $brightness_file" >&2
#| }
#| [ $# -eq 0 ] && { help; exit 1; }
#| v=$1
#| # Check $v is number
#| [ 0 = $(expr "x$v" : '^x[-+]\?[0-9]*$') ] && { echo "Not a number: $v" >&2; help; exit 1; }
#| # Calc new value
#| case "$v" in
#|     -*) read c < "$brightness_file"; b=$(expr "$c" - "${v#-}");;
#|     +*) read c < "$brightness_file"; b=$(expr "$c" + "${v#+}");;
#|     *)  b=$v;;
#| esac
#| # Value range check
#| [ "$b" -lt 1 ] && b=1
#| read max < "$max_brightness_file"
#| [ "$b" -gt "$max" ] && b=$max
#| # Write value
#| echo "$b" | sudo /usr/bin/tee "$brightness_file" >/dev/null
#| 
#| # note sudo's NOPASSWD won't work if there is a duplicate slash
#| # note sudo's NOPASSWD must be in the last line
#- }}}


####FILE +x bin/x-gestures {{{
#| #!/bin/sh
#| pkill -x lisgd
#| lisgd -d /dev/input/event1 \
#|     -g '1,LR,T,*,R,pkill -x -SIGUSR2 wvkbd-mobintl' \
#|     -g '1,RL,T,*,R,pkill -x -SIGUSR1 wvkbd-mobintl' \
#|     -g '1,UD,R,*,P,~/bin/x-brightness -10' \
#|     -g '1,DU,R,*,P,~/bin/x-brightness +10' \
#|     -g '2,UD,T,M,R,swaymsg kill' \
#|     -g '1,UD,T,*,R,~/bin/x-run'
#- }}}


####FILE +x bin/x-hibernate {{{
#| #!/bin/sh
#| 
#| swaylock -c 888888 & sleep .1 && systemctl hibernate
#- }}}


####FILE +x bin/x-mute {{{
#| #!/bin/sh
#| # Usage: ./mute
#| pactl set-sink-mute @DEFAULT_SINK@ toggle
#- }}}


####FILE +x bin/x-picom {{{
#| #!/bin/bash
#| 
#| # To detach:
#| #   ./x-picom -b
#| 
#| pkill --exact picom
#| 
#| picom_args=(
#|     --config /dev/null         # no default config
#|     --no-fading-destroyed-argb # prevent urxvt window from flashing on closing
#|     --no-fading-openclose      # not working? use .config/compton.conf
#|     --xrender-sync-fence       # Avoid "keyboard/mouse lag"; actually the display is not redrawing
#|     --backend xrender          # "xrender" is less laggy than "glx"?
#|     --vsync                    # Avoid tearing
#|     -I1 -O1                    # No fading (workaround)
#| 
#|     # no shadow for maximized windows, unfocused windows and menu
#|     # --shadow-exclude "(widthb > $wsmall || heightb > $hsmall) || !focused" # || (WM_WINDOW_ROLE@:s *= "fluxbox-menu")'
#|     --shadow-exclude "!(window_type *= \"menu\") && (focused || !focused)"
#| )
#| 
#| exec picom "${picom_args[@]}" "$@"
#- }}}


####FILE +x bin/x-run {{{
#| #!/bin/sh
#| 
#| b="#000000dd"
#| f="#00bbdd"
#| hb="#333333"
#| # pkill -x -SIGUSR2 wvkbd-mobintl
#| # bemenu-run -i -l20 --scrollbar auto --counter always -W.3 --nb $b --ab $b --tf $f --hf $f --fbf $f --fbb $hb --hb $hb --fn "Noto Sans Mono 10"
#| cd "$(dirname "$0")"/rundir
#| cmd=$(find . -maxdepth 1 -not -type d | sed 's#^..##' | LC_ALL=C sort | bemenu -i -l20 -p ">" --scrollbar auto -W.33 --nb $b --ab $b --tf $f --hf $f --fbf "#ff3333" --fbb $hb --hb $hb --fn "Noto Sans Mono 33")
#| cwd=$(pwd)
#| cd ~
#| case "$cmd" in
#|     (*@) sh -c "${cmd%@}" ;;
#|     ("") : ;;
#|     (*) sh -c "$cwd/$cmd" & ;;
#| esac
#| # pkill -x -SIGUSR1 wvkbd-mobintl
#- }}}


####FILE +x bin/x-status {{{
#| #!/bin/sh
#| 
#| read bat < /sys/class/power_supply/rk817-battery/capacity
#| read sta < /sys/class/power_supply/rk817-battery/status
#| case "$sta" in
#|     (Charging)         sta=+ ;;
#|     (Full|Discharging) sta=  ;;
#|     (*)                sta=? ;;
#| esac
#| 
#| vol=$(pactl get-sink-volume @DEFAULT_SINK@)
#| vol=${vol% / *}; vol=${vol##* }
#| 
#| read br  < /sys/class/backlight/backlight/brightness
#| read brm < /sys/class/backlight/backlight/max_brightness
#| br=$((100 * br / brm))
#| 
#| dt=$(date +'%Y-%m-%d (%a) %H:%M:%S')
#| 
#| #net=$(echo $(ip a | sed -n '/state UP/s/^[^ ]* \([^ :]*\).*/\1/p'))
#| net=$(echo $(ip -o a | awk '(!/ lo /)&&(!/ inet6 /){if(!a[$2]++){print $2}sub("/.*","",$4);print $4}'))
#| #net=${net:--}
#| 
#| printf '%s  %s :%s *%s  %s\n' "$net" "[$sta$bat%]" "$vol" "$br%" "$dt"
#- }}}


####FILE +x bin/x-term {{{
#| #!/bin/sh
#| 
#| font="Noto Sans Mono:size=10.5"
#| footclient -o font="$font" -e tmux
#- }}}


####FILE +x bin/x-volume {{{
#| #!/bin/sh
#| [ $# -eq 0 ] && { echo "Usage: $0 <volume> (<volume> = 20%, +5%, -10% etc.)"; exit 1; }
#| pactl set-sink-volume @DEFAULT_SINK@ "$1"
#- }}}


####FILE +x bin/xcopy {{{
#| #!/bin/sh
#| 
#| text=$*
#| 
#| wsl_copy() {
#|     # win32yank -i; return
#|     cd /
#| 
#|     magic=ac7i6ma0
#|     tmpdir=/tmp/wslclip
#|     [ ! -d "$tmpdir" ] && mkdir -p "$tmpdir"
#|     pidfile="$tmpdir/copy_pid"
#|     inputfile="$tmpdir/copy_input"
#|     oninitfile="$tmpdir/copy_oninit"
#|     logfile="$tmpdir/copy_log"
#|     log() { printf "%s (sh) %s\n" "$(date +'%Y/%m/%d %H:%M:%S.%3N')" "$*" >> "$logfile"; }
#|     printf "%s\n" "------" >> "$logfile"
#| 
#|     # if "pidfile cannot be read" or "pid written in pidfile no longer exists", start new daemon
#|     if ! read -r pid < "$pidfile" 2>/dev/null || [ ! -e "/proc/$pid/fd/0" ]; then
#|         log "pid=[$pid], $([ -z "$pid" ] && printf "%s" "read $pidfile failed"), $([ -n "$pid" ] && [ ! -e "/proc/$pid/fd/0" ] && printf "%s" "/proc/$pid/fd/0 does not exist")"
#| 
#|         # shellcheck disable=SC2016
#|         pwsh='
#|         # '$magic' wsl-xcopy-pwsh # For pgrep purpose
#|         $wslroot="//wsl$/'"$WSL_DISTRO_NAME"'"
#|         echo a > "$wslroot/'"$oninitfile"'"
#|         function log{ param($msg); $d=$(get-date -Format "yyyy/MM/dd HH:mm:ss.fff"); echo "$d (PS) $msg" >> "$wslroot/'"$logfile"'"}
#|         log init
#|         while(1){
#|             $got = Read-Host
#|             log "read-host done"
#| 
#|             # Assumes base64 encoded UTF-8 data is in $inputfile
#|             #$b64 = Get-Content "$wslroot/'"$inputfile"'"
#|             #$bin = [System.Convert]::FromBase64String($b64)
#|             #$str = [System.Text.Encoding]::UTF8.GetString($bin)
#|             #Set-Clipboard $str
#|             # echo "b64=$b64,str=$str"
#| 
#|             $str = (Get-Content -Raw -Encoding utf8 "$wslroot/'"$inputfile"'")
#|             log "get-content done, str is [$str]"
#|             Set-Clipboard $str
#|             log "set-clipboard done"
#| 
#|         }
#|         '
#| 
#|         mkdir -p "$tmpdir"
#|         touch "$inputfile"
#|         rm "$oninitfile" 2>/dev/null
#| 
#|         # Run powershell and save pid
#|         # This reads $inputfile and save it to clipboard whenever something is written in stdin.
#|         # An alternative is clip.exe, but has encoding problem, not works on some directories, slower than this background-powershell method etc.
#|         # A dummy process is piped to powershell.exe, otherwise we cannot write to its stdin with /proc/$pid/fd/0.
#|         # Also powershell.exe must be piped to something other than stdout, otherwise it does not persist when not launched from terminal (e.g. from vim).
#|         # Replacing "while ..." with "cat" works in terminal, but not in script (infinite loop)
#|         log "starting powershell"
#|         while true; do sleep 100000; done | powershell.exe "$pwsh" > /dev/null &
#|         pid=$!
#|         echo $pid > "$pidfile"
#|         log "PID $pid is written to $pidfile"
#| 
#|         # wait until $oninitfile is created (powershell startup is slow)
#|         # i=0; while [ $((i += 1)) -lt 5000 ] && [ ! -e "$oninitfile" ]; do sleep .01; done
#|         i=0; while [ $((i += 1)) -lt 5000 ] && [ ! -e "$oninitfile" ]; do sleep 0; done
#|         log "$oninitfile created."
#| 
#|     fi
#| 
#|     # { [ -z "$text" ] && cat || printf "%s" "$text"; } | base64 > "$inputfile"
#|     # echo > "/proc/$pid/fd/0"
#|     log "writing to $inputfile"
#|     { [ -z "$text" ] && cat || printf "%s" "$text"; } > "$inputfile"
#|     log "writing to /proc/$pid/fd/0"
#|     echo > "/proc/$pid/fd/0"
#| 
#| }
#| 
#| 
#| ## Main program
#| 
#| if [ -n "${IS_WSL}${WSL_DISTRO_NAME}${WSL_INTEROP}${WSL_ENV}" ]; then # wsl
#|     wsl_copy
#| 
#| elif [ -n "${WAYLAND_DISPLAY}" ]; then # wayland
#|     { [ -z "$text" ] && cat || printf "%s" "$text"; } \
#|         | wl-copy
#|     wl-paste 2>/dev/null | xclip -selection clipboard -i 2>/dev/null &
#|     # note: wl-clipboard-rs is faster than wl-clipboard
#|     # (`time echo a | wl-copy` is 10ms vs 35ms)
#|     # but wl-clipboard-rs does not work on gnome as of early 2024
#| 
#| elif command -v xclip > /dev/null; then # xorg
#|     { [ -z "$text" ] && cat || printf "%s" "$text"; } \
#|         | xclip -selection clipboard -i
#| 
#| elif [ "$PREFIX" != "${PREFIX#*/com.termux/*}" ]; then # termux
#|     { [ -z "$text" ] && cat || printf "%s" "$text"; } \
#|         | termux-clipboard-set
#| 
#| fi
#- }}}


####FILE +x bin/xpaste {{{
#| #!/bin/sh
#| 
#| wsl_paste() {
#|     # win32yank -o; return
#|     cd /
#| 
#|     magic=pklgds25
#|     tmpdir=/tmp/wslclip
#|     [ ! -d "$tmpdir" ] && mkdir -p "$tmpdir"
#|     pidfile="$tmpdir/paste_pid"
#|     outputfile="$tmpdir/paste_output"
#|     readyfile="$tmpdir/paste_ready"
#|     logfile="$tmpdir/paste_log"
#|     log() { printf "%s (sh) %s\n" "$(date +'%Y/%m/%d %H:%M:%S.%3N')" "$*" >> "$logfile"; }
#|     printf "%s\n" "------" >> "$logfile"
#| 
#|     # if "pidfile cannot be read" or "pid written in pidfile no longer exists", start new daemon
#|     if ! read -r pid < "$pidfile" 2>/dev/null || [ ! -e "/proc/$pid/fd/0" ]; then
#|         log "pid=[$pid], $([ -z "$pid" ] && printf "%s" "read $pidfile failed"), $([ -n "$pid" ] && [ ! -e "/proc/$pid/fd/0" ] && printf "%s" "/proc/$pid/fd/0 does not exist")"
#| 
#|         # shellcheck disable=SC2016
#|         pwsh='
#|         # '$magic' wsl-xpaste-pwsh # For pgrep purpose
#|         $wslroot="//wsl$/'"$WSL_DISTRO_NAME"'"
#|         function log{ param($msg); $d=$(get-date -Format "yyyy/MM/dd HH:mm:ss.fff"); echo "$d (PS) $msg" >> "$wslroot/'"$logfile"'"}
#|         log "init"
#|         while(1){
#|             $got = Read-Host
#|             log "read-host done"
#| 
#|             # Encode string as utf8 and then convert to base64
#|             #$str = Get-Clipboard -Raw # without -Raw we get an array of strings
#|             #$bin = ([System.Text.Encoding]::UTF8).GetBytes($str)
#|             #$b64 = [Convert]::ToBase64String($bin)
#|             #echo $b64 > "$wslroot/'"$outputfile"'"
#|             #echo a > "$wslroot/'"$readyfile"'"
#| 
#|             $a = (gcb -Raw).Replace("`r`n", "`n")                   # CRLF to LF
#|             log "a is [$a]"
#|             [IO.File]::WriteAllText("$wslroot/'"$outputfile"'", $a) # no trailing CRLF
#|             log "written to '"$outputfile"'"
#|             echo a > "$wslroot/'"$readyfile"'"
#|             log "written to '"$readyfile"'"
#| 
#|             # "Get-Clipboard -Raw > file" has an encoding problem (which can be fixed with out-file -encoding utf8), and it also adds some garbage leading/trailing bytes
#|             # $str = Get-Clipboard
#|         }
#|         '
#| 
#|         mkdir -p "$tmpdir"
#| 
#|         # Run powershell and save pid
#|         # This writes clipboard content to $outputfile whenever something is written in stdin.
#|         # Simple "powershell.exe Get-Clipboard" works, but very slow
#|         # A dummy process is piped to powershell.exe, otherwise we cannot write to its stdin with /proc/$pid/fd/0.
#|         # Also powershell.exe must be piped to something other than stdout, otherwise it does not persist when not launched from terminal (e.g. from vim).
#|         # Replacing "while ..." with "cat" works in terminal, but not in script (infinite loop)
#|         log "starting powershell"
#|         while true; do sleep 100000; done | powershell.exe "$pwsh" >/dev/null &
#|         pid=$!
#|         echo $pid > "$pidfile"
#|         log "PID $pid is written to $pidfile"
#| 
#|     fi
#| 
#| 
#|     log "removing $outputfile and $readyfile"
#|     rm "$outputfile" "$readyfile" 2>/dev/null
#|     log "writing to /proc/$pid/fd/0"
#|     echo > "/proc/$pid/fd/0"
#|     # i=0; while [ $((i += 1)) -lt 5000 ] && [ ! -e "$readyfile" ]; do sleep .001; done
#|     i=0; while [ $((i += 1)) -lt 5000 ] && [ ! -e "$readyfile" ]; do sleep 0; done
#|     # first tr removes non-base64 characters, second tr fixes CRLF
#|     #cat "$outputfile" | tr -c -d "[:alnum:][+/=]" | base64 -d | tr -d ''
#|     log "$readyfile found, now cat'ing it"
#|     cat "$outputfile"
#| 
#| }
#| 
#| 
#| ## Main program
#| 
#| if [ -n "${IS_WSL}${WSL_DISTRO_NAME}${WSL_INTEROP}${WSL_ENV}" ]; then # wsl
#|     wsl_paste
#| 
#| elif [ -n "${WAYLAND_DISPLAY}" ]; then # wayland
#|     wl-paste -n # must wall wl-copy WITHOUT -n, and wl-paste WITH -n
#| 
#| elif command -v xclip > /dev/null; then # xorg
#|     xclip -selection clipboard -o
#| 
#| elif [ "$PREFIX" != "${PREFIX#*/com.termux/*}" ]; then # termux
#|     termux-clipboard-get
#| 
#| fi
#- }}}


