#!/bin/sh
#vim: fdm=marker fdl=0 fen

# https://codeberg.org/sj2tpgk/dot/raw/branch/master/tmux

errexit() { printf "\033[31;1mERROR: \033[0m%s\n" "$1" >&2; exit 1; }

# Env vars and paths
#   TMUX_ROOT          temporary files are stored here
#   TMUX_SHELL         bash or fish; use this shell for default-command
#   TMUX_SOCKET_NAME   socket name (if set externally, use that one)
#   TMUX_bash          bash
#   TMUX_fish          fish
#   TMUX_cleanup       removes temporary files. run when last session dies

# Environment vars
TMUX_ROOT="$PREFIX"/tmp/tmux-tmp/
export TMUX_ROOT="$TMUX_ROOT"

# Get abs path of this script
# TMUX_SCRIPT="$(cd "$(dirname "$0")"; pwd)" || errexit "could not cd to \$(dirname $0)"
# TMUX_SCRIPT="$abs"/"$(basename "$0")"
# export TMUX_SCRIPT="$TMUX_SCRIPT"

# Init (called when this script is invoked)
_init() {

    # Create "$TMUX_ROOT" directory
    [ "${TMUX_ROOT#$PREFIX/tmp/}" = "$TMUX_ROOT" ] && errexit "TMUX_ROOT $TMUX_ROOT is not in /tmp/"
    if [ -d "$TMUX_ROOT" ]; then
        rm -r -- "$TMUX_ROOT"/*
    else
        mkdir -p "$TMUX_ROOT"
    fi

    # Create $TMUX_ROOT/bin and add it to $PATH
    export PATH="$TMUX_ROOT/bin:$PATH"

    # Extract files from this script
    # TODO optimize quadratic -> linear
    # Awk prints <NR> <permission> <file> e.g. "10 +x bin/foo"
    # Directives:
    #   ####FILE <permission> <file>       Mark the beginning of the file (ends before next ####FILE)
    #                                      (optionally followed by one apace and three open-brace, will be removed)
    #   #| <string>                        Replaced with <string> (may help sh syntax highlighting)
    #   #- <string>                        This line is removed
    if [ 1 -eq 0 ]; then
        awk '/^####FILE/{sub("####FILE ","");sub("{""{{$","");print NR" "$0}' "$0" | while read -r nr permission file; do
            path="$TMUX_ROOT"/"${file##/*}"
            dir=$(dirname "$path")
            # echo "def nr=[$nr], permission=[$permission], path=[$path], dir=[$dir]"
            [ ! -d "$dir" ] && mkdir -p "$dir"
            sed "1,${nr}d;/^####/Q;/^#- /d;s/^#| //" "$0" > "$path"
            case "$permission" in
                ("--") ;;
                ("+x") chmod +x "$path" ;;
                ("*")  errexit "invalid permission specified: $permission (file=$file)" ;;
            esac
        done
    else
        # improved version: no nested loop, no duplicate mkdir
        awk -v T="$TMUX_ROOT/" -v Q="'" '
            BEGIN{nxs=0}
            /^####/{close(out);out=0}
            END{close(out);cmd="chmod +x";for(i=0;i<nxs;i++){cmd=cmd" "Q xs[i] Q};system(cmd)}
            /^#-/{next}
            out{sub("#\\| ?","");print $0>out}
            /^####FILE/{
              out=T"/"$3;outd=out;sub("/[^/]*$","",outd);
              if(!outds[outd]){system("mkdir -p "Q outd Q);outds[outd]=1}
              if($2=="+x"){xs[nxs++]=out}
            }
        ' "$0"
    fi

}

printf '\033[2 q' # block cursor

if [ "$1" = pack ]; then

    dest="$(dirname "$0")"/tmux2
    { cat "$0"; printf "\n\n\n\n"; } > "$dest"
    for i in ~/bin/*; do
        [ -f "$i" ] || continue
        echo "####FILE +x $(echo "$i" | sed 's#.*/\(bin/[^/]*\)$#\1#') {{""{"
        cat "$i" | sed 's/^/#| /' # space after bar is needed
        printf "#- }}""}\n\n\n"
    done >> "$dest"

else

    # Regen conf
    _init
    # Export env vars
    TMUX_SOCKET_NAME=${TMUX_SOCKET_NAME:-default}
    export TMUX_SOCKET_NAME="$TMUX_SOCKET_NAME"

    if [ -z "$(tmux -L "$TMUX_SOCKET_NAME" list-sessions 2>/dev/null)" ]; then
        # If no session => create one
        tmux -L "$TMUX_SOCKET_NAME" -f "$TMUX_ROOT/tmux.conf"
    else
        # If session exists => reload config and run tmux command
        echo Regenerated files in "$TMUX_ROOT"
        tmux -L "$TMUX_SOCKET_NAME" -f "$TMUX_ROOT/tmux.conf" source "$TMUX_ROOT/tmux.conf"
        tmux -L "$TMUX_SOCKET_NAME" -f "$TMUX_ROOT/tmux.conf" "$@"
    fi

fi

exit # Do not remove this exit
# ==== Shell script ends here ====


# ==== Now follows embedded files ====


####FILE +x bin/ra {{{
#!/bin/sh
f() { echo "$@"; "$@"; }
# f() { echo "$@"; }
[ "$MYKBD" = colemakdh ] && flag=a || a=""
# Note: $(x=${flag:+val1}; echo ${x:-val2}) is val1 if $flag is nonempty else val2
exec ranger --clean \
    --cmd "set show_hidden       on" \
    --cmd "set tilde_in_titlebar on" \
    --cmd "set shorten_title     3" \
    --cmd "set update_title      on" \
    --cmd "map S shell $(tmux -L "$TMUX_SOCKET_NAME" show -qvg default-command)" \
    --cmd "map $(x=${flag:+k}; echo ${x:-h}) move left=1" \
    --cmd "map $(x=${flag:+n}; echo ${x:-j}) move down=1" \
    --cmd "map $(x=${flag:+e}; echo ${x:-k}) move up=1" \
    --cmd "map $(x=${flag:+i}; echo ${x:-l}) move right=1" \
    --cmd "map $(x=${flag:+K}; echo ${x:-H}) history_go -1" \
    --cmd "map $(x=${flag:+I}; echo ${x:-L}) history_go +1" \
    --cmd "map $(x=${flag:+N}; echo ${x:-J}) move down=0.5 pages=True" \
    --cmd "map $(x=${flag:+E}; echo ${x:-K}) move up=0.5   pages=True" \
    --cmd "map $(x=${flag:+j}; echo ${x:-n}) search_next" \
    --cmd "map $(x=${flag:+J}; echo ${x:-N}) search_next forward=False" \
    --cmd "map $(x=${flag:+L}; echo ${x:-I}) eval fm.open_console('rename ' + fm.thisfile.relative_path.replace('%', '%%'), position=7)" \
    "$@"
#- }}}


####FILE +x bin/TMUX_bash {{{
#!/bin/sh
INPUTRC="$TMUX_ROOT/inputrc" exec bash --rcfile "$TMUX_ROOT/bashrc"
#- }}}


####FILE +x bin/TMUX_cleanup {{{
#!/bin/sh
# Remove $TMUX_ROOT dir when all tmux sessions are closed
if [ "$(tmux -L "$TMUX_SOCKET_NAME" list-sessions | wc -l)" = 0 ]; then
    # Ensure not to remove wrong thing
    [ "${TMUX_ROOT#$PREFIX/tmp/}" = "$TMUX_ROOT" ] && exit 1
    [ ! -d "$TMUX_ROOT" ] && exit 1
    rm -r "$TMUX_ROOT"
fi
#- }}}


####FILE +x bin/TMUX_fish {{{
#!/bin/sh
sav=$XDG_CONFIG_HOME
export XDG_CONFIG_HOME="$TMUX_ROOT/config"
export SHELL=TMUX_fish
if [ -z "$sav" ]; then
    exec fish -C "set -e XDG_CONFIG_HOME"
else
    exec fish -C "set -xg XDG_CONFIG_HOME '$sav'"
fi
#- }}}


####FILE -- config/fish/config.fish {{{
# using older syntax for compatibility
[ -d "/data/data/com.termux/files/home/bin/" ]; and set -x PATH $PATH:/data/data/com.termux/files/home/bin/
set fish_color_autosuggestion magenta
set fish_color_command cyan
#| function fish_greeting; end
#| function mkcd; mkdir -p $argv[1]; and cd $argv[1]; end
#| function ssh; SHELL=/bin/sh command ssh $argv; end # avoid TMUX_fish error when using ssh -J (not proper fix)
#| for i in f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12; bind -k $i ""; or bind -e $i; end 2>/dev/null
#| for i in \e\[25\;2~ \e\[26\;5~; bind $i ""; or bind -e $i; end 2>/dev/null
#| bind \eg "commandline -r (commandline -b | sed 's#\s*\$# | grep -i #')"
#| command -v doas >/dev/null 2>&1; and alias sudo doas
#| bind ctrl-c cancel-commandline
#| alias sr "string replace"; function s0;begin;string match -qr '^[1-9][0-9]*$' $argv[1]; and string repeat -Nn $argv[1] \n;cat;end|string split0;true;end # need cat to force read from stdin in a function
#- }}}


####FILE -- bashrc {{{
conf() { sed "0,/^#===$1/d;/^#===/Q;s/^###//" "$TMUX_CONF"; }
command -v nvim >/dev/null && nv() { nvim -u <(conf vim) "$@"; }
command -v vim  >/dev/null && v()  { vim  -u <(conf vim) "$@"; }
_exitstatus() { local s=$?; [[ $s == 0 ]] && echo "" || echo -e "\e[31m$s\e[0m "; }
export PS1="\[\e[36m\]\w\[$(tput sgr0)\] \$(_exitstatus)>>> "
mkcd() { mkdir -p "$1" && cd "$1"; }
alias la='ls -la'
#- }}}


####FILE -- inputrc {{{
Tab:    menu-complete
"\e[Z": complete
"\C-w": shell-backward-kill-word
"\e[A": history-search-backward
"\e[B": history-search-forward
set show-all-if-ambiguous        on  # Tab -> partial completion and show candidates
set show-all-if-unmodified       on  #
set colored-stats                on  # Color files by types
set visible-stats                on  # Append char to indicate type
set mark-symlinked-directories   on  # Mark symlinked directories
set colored-completion-prefix    on  # Color the common prefix
set menu-complete-display-prefix on  # Color the common prefix in menu-complete
set eo-control-characters        off # Don't show ^C etc.
set enable-bracketed-paste       off # Workaround (https://github.com/hanslub42/rlwrap/issues/108)
set completion-ignore-case       on  # Case insensitive completion
#- }}}


####FILE -- tmux.conf {{{
set -g default-shell /bin/sh
set-hook -g session-closed 'run TMUX_cleanup'

# Seems "setenv -g" does not affect variables within .tmux.conf (but do affect in child proc)
EDITOR="$TMUX_ROOT/bin/v"
VISUAL="$TMUX_ROOT/bin/v"

# Set shell ( if $TMUX_SHELL is set, use that shell )
if "if [ -n '#{TMUX_SHELL}' ]; then [ fish = '#{TMUX_SHELL}' ]; else command -v fish >/dev/null; fi" \
    "set -g default-command 'TMUX_fish'" \
    "set -g default-command 'TMUX_bash'"
    # set -g default-command 'exec fish -C "function conf; sed \"0,/^#===\$argv[1]/d;/^#===/Q;s/^###//\" \"'"$TMUX_CONF"'\"; end; conf fish | source"' # exec needed? to change cwd of pane process
    # set -g default-command 'd=$(mktemp -d "$PREFIX"/tmp/tmux-temp-conf-XXXXXX); sed "0,/^#===inputrc/d;/^#===/Q;s/^###//" '"$TMUX_CONF"' > "$d/1"; sed "0,/^#===bash/d;/^#===/Q;s/^###//" '"$TMUX_CONF"' > "$d/2"; INPUTRC="$d/1" bash --init-file "$d/2"; rm "$d/1" "$d/2"; rmdir "$d"'

set -g escape-time 0
set -g mouse       on

run-shell -b 'p=$(myprompt -- --tmux --short | sed "s/ .*//"); tmux set -g status-left "#[nobold]$p [##S] "'
set -g status-left-length 20
set -g status-right       '#{s#^'$HOME'#~#;s#/\$##;s#([-._]*[^/])[^/]*/#\1/#g:pane_current_path} [#{s/^(..)...*(..)$/\1.\2/:user}@#{s/^(..)...*(..)$/\1.\2/:host}]'
set -g status-position    top
set -g pane-active-border-style fg=yellow

set -g status-style                 bg=0,fg=7,bold
set -g window-status-style          bg=0,fg=1,bold
set -g window-status-current-style  bg=0,fg=1,bold,reverse
set -g window-status-format         " #I:#W#F "
set -g window-status-current-format " #I:#W#F "
set -g window-status-separator      ""

bind    '"'   split-window -vc "#{pane_current_path}"
bind    s     split-window -vc "#{pane_current_path}"
bind    %     split-window -hc "#{pane_current_path}"
bind    v     split-window -hc "#{pane_current_path}"
bind    w     new-window   -c  "#{pane_current_path}"
bind    r     run "$TMUX_SCRIPT" \; source "$TMUX_ROOT/tmux.conf" \; display "Reloaded .tmux.conf"
bind -r o     select-pane -t :.+
bind -r n     next-window
bind -n F3    next-window
bind -n F4    select-pane -t :.+
bind -r Left  resize-pane -L 1
bind -r Down  resize-pane -D 1
bind -r Up    resize-pane -U 1
bind -r Right resize-pane -R 1
bind -r <     swap-pane -d -t -1
bind -r >     swap-pane -d -t +1

# Completion using fzf
bind    Tab      run "$TMUX_ROOT/bin/tmux_textcomplete.sh"

# Use xcopy if exists (todo: add to main config)
if-shell "command -v xcopy >/dev/null" "set -q copy-command xcopy"

# hide status on zoom
set-hook -g after-resize-pane 'if "[ #{window_zoomed_flag} -eq 1 ]" "set -g status off" "set -g status on"'

# Load local config
if-shell "test -f '$HOME/.tmux.conf.local'" "source \"$HOME/.tmux.conf.local\""
#- }}}


####FILE -- vimrc {{{
#| " vim
#| if filereadable($VIMRUNTIME . "/defaults.vim") | source $VIMRUNTIME/defaults.vim | endif
#| set et nocp sm hid nosc
#| syntax on| filetype on| filetype plugin indent on
#| set ls=2 stl=[%{&readonly?'R':''}%{&modified?'+':'-'}]\ \ %<%f%*%=%-10.(%l,%c%V%)\ %y%6.(%P%)
#| nn s/ :noh<cr>:let @/ = ""<cr>
#| " neovim
#| set ai sw=4 ts=4 sr mouse=av so=1 siso=5 tw=0 nu sb spr cf acd wic ic scs is hls ttm=0 t_Co=16
#| for i in range(1, 16) | for j in ["", "s-", "c-"] | for k in ["", "i", "c"] | exe k . "nore <" . j . "f" . i . "> <nop>" | endfor | endfor | endfor
#| nn Q :q<cr>| ino <s-f13> <nop>| ino <c-f14> <nop>| nn D dd| nn Y yy| nn ss :sp<cr>| nn sv :vsp<cr>| nn sb :bd<cr>| nn so <c-w>o| nn :<cr> :wa<cr>| nn <a-j> J| nn M J| nn - <c-w>w| nnore + :tabnext<cr>| nn > >>| nn <lt> <lt><lt>| nn U <c-r>| nno <space> <c-d>| nno <backspace> <c-u>| no <cr> K
#| " no <esc>[25;2~ <nop>| ino <esc>[25;2~ <nop>| no <esc>[26;5~ <nop>| ino <esc>[26;5~ <nop>
#| no j gj| no k gk| no gj j| no gk k| no J <c-d>| no K <c-u>| no h h| no l l| no gh 0| no gl <end>| no i i| no I I| no si s| no n n| no N N| no e e| no E E| ono e e| ono E E| ono h 0| ono l $| ono iw iw| ono iW iW| nno H <c-o> |nno L <c-i>
#| if $MYKBD == "colemakdh" | no n gj| no e gk| no gn j| no ge k| no N <c-d>| no E <c-u>| no k h| no i l| no gk 0| no gi <end>| no l i| no L I| no sl s| no j n| no J N| no h e| no H E| ono h e| ono H E| ono k 0| ono i $| ono lw iw| ono lW iW| nno K <c-o> |nno I <c-i> | endif
#| ono m %| nn m %| nn yb mzggVGy'z| nn db mzggVGd'z
#| exe "au InsertEnter * set cul"| exe "au InsertLeave * set nocul"
#|
#| if has("nvim") | exe "au ColorScheme * set notgc | hi Pmenu ctermfg=1 ctermbg=0" | colo vim | endif
#|
#| " Save/restore view
#| aug view
#| au!
#| au BufWinLeave * if expand('%') != '' && &bt !~ 'nofile' | sil! cal mkdir(&vdir,'p') | mkvie | end
#| au BufWinEnter * if expand('%') != '' && &bt !~ 'nofile' | sil! lo | end
#| aug END
#|
#| " Clipboard
#| set clipboard=unnamedplus
#| " If my clipboard wrapper is available, use it.
#| if executable("xcopy") && executable("xpaste")
#|     let g:clipboard = { 'name': 'my', 'copy': { '+': 'xcopy', '*': 'xcopy', }, 'paste': { '+': 'xpaste', '*': 'xpaste', }, 'cache_enabled': 1, }
#| endif
#|
#| " Basic auto completion
#| inore <tab>       <c-n>
#| inore <plug>MyTab <c-n>
#| inore <s-tab>     <c-p>
#| inore <expr> <cr> pumvisible() ? "\<c-y>\<cr>" : "\<cr>"
#| set shm+=c cot=menuone,noinsert,noselect noinf
#| " Auto complete (https://stackoverflow.com/questions/35837990)
#| fu! OpenCompletion()
#|     " check (menu invisible && inserting iskeyword char && at least minlen chars)
#|     let minlen = 2
#|     if !pumvisible() && (v:char =~ '\K') && (minlen == 1 || (col(".") >= (minlen-1) && matchstr(getline("."), '\%' . (col('.')-(minlen-1)) . 'c\K\{' . (minlen-1) . '\}') != ""))
#|         call feedkeys("\<plug>MyTab", "")
#|         " feedkeys("\<c-n>", "") will mess up repeating
#|     endif
#| endfu
#| " au InsertCharPre * call OpenCompletion()
#|
#| " Basic linter integration (press | key)
#| nnore <bar> :sil call Linter(0)<cr>
#| " au CursorHold *.pl call Linter(1)
#| set updatetime=700
#| au FileType sh setl makeprg=shellcheck\ -f\ gcc\ %:S
#| au FileType perl setl makeprg=perlcritic\ --verbose\ 1\ -3\ %:S
#| set ar aw
#| fu! Linter(nomove)
#|     let qf = 0 " quickfix open?
#|     for i in range(1, winnr('$')) | let qf += getwinvar(i, '&syntax') == 'qf' | endfo
#|     if empty(bufname("."))
#|         return
#|     elseif (getbufinfo(".")[0].changed || !qf) && executable(split(&makeprg)[0])
#|         let [s1, s2] = [winnr(), getpos(".")]
#|         sil make | cope
#|         while winnr() != s1 | exec "norm! \<c-w>w" | endwh | call setpos(".", s2)
#|     elseif !a:nomove
#|         try | cnext | catch | cfirst | endtry
#|     endif
#|     " For neovim, check vim.diagnostic.{show,fromqflist}, vim.system, vim.schedule
#| endf
#- }}}




####FILE +x bin/7zenc {{{
#| #!/bin/sh
#| 
#| [ $# -le 1 ] && { echo "Usage: $0 [-n] <archive_name> [<file_names> ...]"; echo "  -n  no password in file name"; exit 1; }
#| nopass=0
#| [ "$1" = -n ] && { nopass=1; shift; }
#| arc=$1
#| shift
#| [ "${arc%.7z}" = "$arc" ] && { echo "archive name not ending with .7z"; exit 1; }
#| pw=$(tr -dc '0-9a-z' </dev/urandom | head -c 10)
#| [ "$nopass" = 0 ] && arc="${arc%.7z}-$pw.7z"
#| 7z a -bb0 -mhe=on -p"$pw" "$arc" "$@"
#| echo
#| echo "Password: $pw"
#- }}}


####FILE +x bin/aider-local {{{
#| #!/bin/sh
#| 
#| export OPENAI_API_BASE="${OPENAI_API_BASE:-http://localhost:8888/v1}"
#| export OPENAI_API_KEY="${OPENAI_API_BASE:-NONE}" # important: see https://github.com/Aider-AI/aider/issues/2209#issuecomment-2888776946
#| export OPENAI_API_KEY="${OPENAI_API_BASE:-NONE}" # important: see https://github.com/Aider-AI/aider/issues/2209#issuecomment-2888776946
#| 
#| if ! command -v aider >/dev/null; then
#|     echo "Aider not found"
#|     aider_dir=~/.local/share/aider
#|     printf %s "install to $aider_dir now? [y/n] "
#|     read -r answer
#|     if [ "$answer" != y ]; then
#|         exit 1
#|     fi
#|     mkdir -p "$aider_dir"
#|     cd "$aider_dir" || exit 1
#|     python -m venv .venv
#|     .venv/bin/pip install aider-install
#|     .venv/bin/aider-install
#| fi
#| 
#| #model_settings=/tmp/aider_model_settings
#| #echo '
#| #- name: llama_cpp/Qwen3-30B-A3B
#| #  extra_params:
#| #    api_key: NONE
#| #- name: llama_cpp/Qwen3-0.6B
#| #  extra_params:
#| #    api_key: NONE
#| #' > "$model_settings"
#| # api_base: http://localhost:8889/ # seems setting different endpoint (port) per model is not working?
#| 
#| # note: extra_params sets .options.keepalive, .options.think etc. field of request body not the .keepalive or .think at the root of the json object
#| 
#| export TERM=linux # force 16 colors
#| 
#| exec aider \
#|     --user-input-color       white   \
#|     --tool-warning-color     yellow  \
#|     --tool-error-color       red     \
#|     --assistant-output-color green   \
#|     --code-theme             monokai \
#|     --weak-model             openai/"${WEAK_MODEL:-Qwen3-0.6B}" \
#|     --model                  openai/"${MODEL:-Qwen3-32B}" \
#|     --no-check-update \
#|     --no-show-release-notes \
#|     --no-show-model-warnings \
#|     --analytics-disable \
#|     "$@"
#|      # --model-settings-file   "$model_settings" \
#|     # --weak-model             openai/Qwen3-0.6B \
#- }}}


####FILE +x bin/archsetup {{{
#| #!/bin/sh
#| 
#| # Install essential packages
#| 
#| # Usage: archsetup [-n] [-y]
#| # Options:
#| #    -n   dry run
#| #    -y   yes to all
#| 
#| dryrun= yes=
#| while [ $# -ge 1 ]; do case "$1" in (-n) dryrun=1;; (-y) yes=1;; esac; shift; done
#| 
#| ask() {
#|     if [ "$dryrun" ]; then printf "> %s\n" "$*"; return 0; fi
#|     if [ "$yes" ]; then ask_answer=y; else printf "%s [y/n] " "$*"; read -r ask_answer; fi
#|     if test "$ask_answer" == y; then "$@"; fi
#| }
#| 
#| ask pacman --noconfirm -S anthy atool bluez bluez-utils dash entr fish fzf git imagemagick jq man man-db mosh neovim nawk nmap openssh pacman-contrib pv ranger rsync tmux unzip pv w3m wget zip
#| 
#| ask pacman --noconfirm -S foot fyi grim keyd labwc ly pipewire swaybg swaylock wl-clipboard wlr-randr
#| 
#| ask pacman --noconfirm -S claws-mail firefox mousepad mpv udiskie pcmanfm
#| 
#| ask pacman --noconfirm -S docker
#| 
#| # xorg
#| # ask pacman -S openbox xterm xorg xorg-xinit arandr xclip picom rxvt-unicode feh tint2 lxappearance lxappearance-obconf
#- }}}


####FILE +x bin/args {{{
#| #!/bin/sh
#| 
#| idx=1
#| for i in "$@"; do
#|     printf "%s\t[%s]\n" "$idx" "$i"
#|     idx=$((idx + 1))
#| done
#- }}}


####FILE +x bin/c {{{
#| #!/bin/sh
#| 
#| has(){
#|     command -v "$1" >/dev/null 2>&1
#| }
#| 
#| show(){
#|     path="$1"
#|     case "$path" in
#|         (!*) path=$(command -v "${path#?}") ;;
#|     esac
#|     # output is piped etc
#|     if ! [ -t 1 ]; then
#|         cat "$path"
#|         return
#|     fi
#|     # do not use exec to invoke highlight to etc so show() can be called multiple times
#|     if has highlight; then
#|         name=${path##*/}
#|         args=
#|         case "$name" in
#|             (Dockerfile*) args="-S dockerfile" ;;
#|             (Makefile*) args="-S makefile" ;;
#|             (*.service|*.automount|*.link|*.mount|*.network|*.path|*.slice|*.socket|*.target|*.timer) args="-S conf" ;;
#|             (*.html|*.htm|*.php) has w3m && { w3m -dump -T text/html -cols "$(tput cols)" "$path"; return; } ;;
#|             (*)
#|                 case "$path" in
#|                     (/etc/netctl/*) args="-S conf" ;;
#|                 esac ;;
#|         esac
#|         highlight --out-format ansi --stdout --force $args "$path"
#|     elif has bat; then
#|         bat --theme ansi -p -P "$path"
#|     else
#|         cat "$path"
#|     fi
#| }
#| 
#| case $# in
#|     (0) cat ;;
#|     (1) show "$1" ;;
#|     (*) echo "Usage: $0 [[!]file]" ; exit 1 ;;
#| esac
#- }}}


####FILE +x bin/chat {{{
#| #!/bin/sh
#| 
#| NEWL='
#| '
#| 
#| default_u=localhost:11434; default_s='Respond concisely. Do not overuse tables. /no_think /nothink'
#| flag_c=; flag_e=; flag_h=; flag_l=; flag_n=
#| opt_m=; opt_s=$default_s; opt_u=$default_u
#| prompt=''
#| # shellcheck disable=SC2016
#| # Duplicate : to escape it
#| #tools='get_time:get current time:timezone=time zone:format=format (you can use %Y %m %d %H %M %S):TZ=$timezone date +"$format"
#| #list_files:list files in dir:dir=directory (use . for current dir):recursive=if nonempty, list files recusively:ls "${recursive::+-R}" "$dir"
#| #cat_file:show contents of a file:path=path to the file:cat "$path"'
#| toolsDefault='shell:run shell command (allowed commands:: date ls find cat grep head tail):cmd=command to run:if echo " date ls find cat grep head tail "|grep -q " ${cmd%% *} ";then sh -c "$cmd";else echo forbidden command;fi'
#| tools=
#| # TODO require tool confirm (e.g. by prefix its name with !)
#| 
#| while [ $# -ge 1 ]; do
#|     case "$1" in
#|         (-[!-][!-]*)  _1=${1#?} ; shift ; set -- "-${_1%"${_1#?}"}" "-${_1#?}" "$@" ;;
#|         (-c|--continue) flag_c=1  ; shift ;;
#|         (-e|--erase)    flag_e=1  ; shift ;;
#|         (-h|--help)     flag_h=1  ; shift ;;
#|         (-l|--list)     flag_l=1  ; shift ;;
#|         (-n|--noout)    flag_n=1  ; shift ;;
#|         (-m|--model)    opt_m="$2"; shift 2 ;;
#|         (-s|--system)   opt_s="$2"; shift 2 ;;
#|         (-u|--url)      opt_u="$2"; shift 2 ;;
#|         (-t|--tool)     [ "$2" = default ] && tools="$tools$NEWL$toolsDefault" || tools="$tools$NEWL$2"; shift 2 ;;
#|         (*) prompt="$*" ; break ;;
#|     esac
#| done
#| 
#| # echo "flag_e=[$flag_e] flag_h=[$flag_h] flag_l=[$flag_l] flag_n=[$flag_n] opt_m=[$opt_m] opt_u=[$opt_u] opt_s=[$opt_s] prompt=[$prompt]"; exit
#| 
#| help(){
#|     echo "Usage: $0 [options ...] [prompt ...]"
#|     echo "       cmd | $0 [options ...]"
#|     echo
#|     echo "Options:"
#|     echo "  -c, --continue         Continue upon previous tool calling"
#|     echo "  -e, --erase            Erase history before starting"
#|     echo "  -h, --help             Help"
#|     echo "  -l, --list             List models"
#|     echo "  -m, --model <model>    Model         (default: auto)"
#|     echo "  -n, --noout            No chat output file (still creates history)"
#|     echo "  -s, --system <prompt>  System prompt (default: $default_s)"
#|     echo "  -t, --tool <spec>      Define additional tools (\"default\" will enable default tools)"
#|     echo "  -u, --url <url>        URL of server (default: $default_u)"
#|     echo
#|     echo "Tool spec example:"
#|     echo "$toolsDefault"
#| }
#| 
#| error(){
#|     echo "Error: $*" >&2; exit 1
#| }
#| 
#| 
#| ## Various checks
#| 
#| missing=
#| for i in curl jq stdbuf; do
#|     if ! command -v "$i" >/dev/null; then
#|         missing="$missing $i"
#|     fi
#| done
#| [ "$missing" ] && error "command not available:$missing"
#| 
#| [ "$flag_h" ] && { help; exit 0; }
#| 
#| res=$(curl -fs "$opt_u"/v1/models 2>/dev/null)
#| _sta=$?
#| [ "$_sta" -ne 0 ] && error "getting model list: server error"
#| 
#| models=$(echo "$res" | jq -r '.data[].id' 2>/dev/null) # do not care newlines
#| _sta=$?
#| [ "$_sta" -ne 0 ] && error "getting model list: format error"
#| 
#| [ ! "$opt_m" ] && opt_m=$(echo "$models" | head -n1)
#| 
#| [ "$flag_l" ] && { echo "$models"; exit 0; }
#| 
#| echo "$models" | grep -qFx "$opt_m" || error "model \"$opt_m\" is not available"
#| 
#| 
#| ## Tools
#| 
#| tools_api=$(echo "$tools" | jq -R 'select(length>0)|[sub("::";"=x=x=";"g")|split(":")[]|sub("=x=x=";":";"g")]|{type:"function",function:{name:.[0],description:.[1],parameters:.[2:-1]|{type:"object",required:[.[]|split("=")[0]],properties:[.[]|split("=")|{key:.[0],value:{type:"string",description:.[1]}}]|from_entries}}}' | jq -s .)
#| tools_int=$(echo "$tools" | jq -R 'select(length>0)|[sub("::";"=x=x=";"g")|split(":")[]|sub("=x=x=";":";"g")]|{key:.[0],value:{flags:"",cmd:.[-1]}}' | jq -s 'from_entries')
#| 
#| # printf "tools_api=%s\ntools_int=%s\n" "$tools_api" "$tools_int" >&2; exit
#| 
#| # tools="[{
#| #    \"type\": \"function\",
#| #    \"function\": {
#| #        \"name\": \"get_time\",
#| #        \"description\": \"Get current time\",
#| #        \"parameters\": {
#| #            \"type\": \"object\",
#| #            \"properties\": {
#| #                \"timezone\": { \"type\": \"string\", \"description\": \"timezone\" }
#| #            },
#| #            \"required\": [\"timezone\"]
#| #        }
#| #    }
#| # }]"
#| 
#| 
#| ## Build query
#| 
#| histfile=${TMPDIR:-/tmp}/chat-hist
#| [ "$flag_e" ] && rm -f "$histfile"
#| touch "$histfile"
#| 
#| if [ ! "$flag_c" ]; then
#|     if [ -t 0 ]; then printf %s "$prompt"; else cat; fi \
#|         | jq -Rs '{role:"user",content:.}' \
#|         >> "$histfile"
#| fi
#| 
#| outdir=$HOME/.cache/chat/
#| mkdir -p "$outdir"
#| outfile="$outdir"/chat-"$(date +%Y%m%d-%H%M%S)".txt
#| [ "$flag_n" ] && outfile=${TMPDIR:-/tmp}/chat-out
#| {
#|     jq -r 'if .content then "<\(.role)>\n\(.content)\n" else empty end' "$histfile"
#|     printf "<assistant>\n"
#| } > "$outfile"
#| 
#| cleanup(){ [ ! "$flag_n" ] || rm -f "$outfile"; }
#| trap cleanup INT TERM
#| 
#| 
#| ## Main API call
#| 
#| # note: avoid including arbitrarily large strings in command parameter (use pipe instead)
#| 
#| # shellcheck disable=SC2016
#| jq -s --arg m "$opt_m" --arg s "$opt_s" --argjson t "$tools_api" \
#|     '{model:$m,stream:true,tools:$t,messages:[{role:"system",content:$s},.[]]}' \
#|     "$histfile" \
#|     | stdbuf -o0 curl -fNs "$opt_u"/v1/chat/completions -d @- \
#|     | stdbuf -i0 -o0 jq -Rcj --unbuffered 'foreach (inputs|if startswith("data: {") then .[6:] else empty end|fromjson) as $x ([null];[$x,.[0]];.)|. as [$x,$y]|(try $y.choices[].delta.reasoning_content catch false) as $pr|if $x.timings then [(if $pr then "\u001b[0m\n" else empty end),"\nTIME: ",($x.timings|{model:$x.model,prompt_ms,predicted_ms,predicted_n,predicted_per_second}),"\n"][] else ($x.choices[].delta|if .reasoning_content then .reasoning_content|[(if $pr then empty else "\u001b[35m" end),.][] else (if .content then .content elif .tool_calls then .tool_calls[0]|((if .id then "TOOL: \(.function.name) " else "" end)+.function.arguments) else empty end)|[(if $pr then "\u001b[0m\n" else empty end),.][] end) end' \
#|     | stdbuf -i0 -o0 tee -a "$outfile"
#| 
#| # shellcheck disable=SC2016
#| tac "$outfile" | awk -v a="$(printf '\033[35m')" -v b="$(printf '\033[0m')" '/^(TIME|TOOL): /{next}/^<assistant>$/{exit}index($0,b){f=1}(!f){print}index($0,a){f=0}' | tac \
#|     | jq -Rs '{role:"assistant",content:.}' \
#|     >> "$histfile"
#| 
#| 
#| ## Tool call
#| 
#| tool_call=$(sed -n 's/^TOOL: //p' "$outfile")
#| if [ "$tool_call" ]; then
#|     tool_cmd=$(echo "$tool_call" | jq -rR --argjson t "$tools_int" 'split(" ")|[.[0],(.[1:]|join(" ")|fromjson|[to_entries[]|"\(.key|@sh)=\(.value|@sh)"]|join(" "))]|"env \(.[1]) sh -c \($t[.[0]].cmd|@sh)"')
#|     tool_result=$(eval "$tool_cmd" 2>&1)
#|     printf "\ncmd:  %s\nout:  %s\n\n" "$tool_cmd" "$tool_result" >&2
#|     id=$(date +"tc_%Y%m%d_%H%M%S")
#|     printf %s "$tool_call" | jq -Rsr --arg id "$id" 'split(" ")|{role:"assistant",tool_calls:[{id:$id,type:"function",function:{name:.[0],arguments:(.[1:]|join(" "))}}]}' >> "$histfile"
#|     printf %s "$tool_result" | jq -Rsr --arg id "$id" '{role:"tool",tool_call_id:$id,content:.}' >> "$histfile"
#|     "$0" -u "$opt_u" -m "$opt_m" -c "${flag_n:+-n}"
#| fi
#| 
#| 
#| ## Cleanup
#| 
#| cleanup
#- }}}


####FILE +x bin/colorscheme {{{
#| #!/bin/sh
#| 
#| colors=${1:-myd}
#| output=${2:-foot}
#| 
#| f_rangef() {
#|     # f_range a b x
#|     # convert 0..a to 0..b
#|     awk "BEGIN{printf \"%f\", ($2*$3)/($1); exit}"
#| }
#| 
#| colors_myd() {
#|     back=10191f
#|     fore=c6cfd8
#|     curf=222222
#|     curb=f9f5f4
#|     alph=85
#| 
#|     dk=18262F
#|     bk=38464F
#|     dr=EF5253
#|     br=FF6263
#|     dg=7CC844
#|     bg=8CD854
#|     dy=E4B51C
#|     by=F4C52C
#|     db=33B5E1
#|     bb=43C5F1
#|     dm=A363D5
#|     bm=B373E5
#|     dc=52CBB0
#|     bc=62DBC0
#|     dw=C6CfD8
#|     bw=D6DFD8
#| }
#| 
#| colors_myb() {
#|     back=f4f2f2
#|     fore=444433
#|     curf=f4f2f2
#|     curb=333333
#|     alph=93
#| 
#|     dk=f8f4f4
#|     bk=f8f4f4
#|     dr=ee2222
#|     br=ff3333
#|     dg=006600
#|     bg=228822
#|     dy=c07700
#|     by=c88018
#|     db=1111aa
#|     bb=3333cc
#|     dm=aa5599
#|     bm=bb66aa
#|     dc=008888
#|     bc=00aaaa
#|     dw=444433
#|     bw=444433
#| }
#| 
#| copy_colors() {
#|     # c_d_0=$dk c_b_0=$bk c_0=$dk c_8=$bk
#|     j=0
#|     for i in k r g y b m c w; do
#|         eval "c_d_$j=\$d$i c_b_$j=\$b$i c_$j=\$d$i c_$((j + 8))=\$b$i"
#|         j=$((j + 1))
#|     done
#| }
#| 
#| output_foot() {
#|     # echo \-o colors.regular2=ff0000
#|     for i in $(seq 0 7); do eval "printf '%s ' \"-o colors.regular$i=\$c_d_$i\""; done
#|     for i in $(seq 0 7); do eval "printf '%s ' \"-o colors.bright$i=\$c_b_$i\""; done
#|     printf '%s ' "-o colors.foreground=$fore"
#|     printf '%s ' "-o colors.background=$back"
#|     printf '%s ' "-o colors.alpha=$(f_rangef 100 1.0 "$alph")"
#| }
#| 
#| output_osc4() {
#|     # /bin/printf '\033]4;2;#ff0000;\007'
#|     for i in $(seq 0 7); do eval "/bin/printf '\\033]4;$i;#\$c_d_$i;\\007'"; done
#|     for i in $(seq 0 7); do eval "/bin/printf '\\033]4;$i;#\$c_b_$i;\\007'"; done
#| }
#| 
#| if ! type "colors_$colors" 2>/dev/null | grep -q function; then
#|     echo "color scheme '$colors' is not defined"
#|     exit 1
#| elif ! type "output_$output" 2>/dev/null | grep -q function; then
#|     echo "output type '$output' is not defined"
#|     exit 1
#| fi
#| 
#| "colors_$colors"
#| copy_colors
#| "output_$output"
#- }}}


####FILE +x bin/dt {{{
#| #!/bin/sh
#| 
#| date +"%Y%m%d-%H%M%S"
#- }}}


####FILE +x bin/du1 {{{
#| #!/bin/sh
#| 
#| du -d1 -BM "${1:-.}" | sort -n
#- }}}


####FILE +x bin/du2 {{{
#| #!/bin/sh
#| 
#| du -d2 -BM $1 | sort -n
#- }}}


####FILE +x bin/ec {{{
#| #!/bin/sh
#| 
#| # emacsclient -a nano -nw -c "$@"
#| 
#| if [ -n "$TMUX" ]; then
#|   # TERM=xterm-direct emacsclient -a nano -c -nw "$@"
#| 
#|   # Non-truecolor (when using rxvt-unicode packge)
#|   TERM=xterm-256color emacsclient -a nano -c -nw "$@"
#| else
#|   TERM=st-direct emacs -a nano -c -nw "$@"
#| fi
#| 
#- }}}


####FILE +x bin/en {{{
#| #!/bin/sh
#| 
#| # emacs -nw --color=yes "$@"
#| # emacs -nw --color=auto "$@"
#| # TERM=screen-16color
#| # emacs -nw --color=256 "$@"
#| 
#| # Guide for emacs + tmux + truecolor
#| # When using urxvt-truecolor
#| # In .tmux.conf
#| #   default-terminal = screen-256color
#| #   terminal-overrides = ",$TERM:Tc"
#| #   ($TERM gets expanded to default-terminal (screen-256color)
#| # When launching emacs,
#| #   if inside  tmux, use TERM=xterm-direct
#| #   if outside tmux, use TERM=st-direct
#| # Diagnose:
#| #   - check if 24bit-colors.sh show smoothly changing colors
#| #   - "TERM=xxxx emacs -nw -Q --eval '(list-colors-display)'"
#| #     to check (1) it shows 500~ colors and (2) color code emacs says and that of colorpicker matches.
#| # Still a problem:
#| #   if server run on low colors and client in true-color, crash.
#| 
#| if [ -n "$TMUX" ]; then
#|   emacs -nw --color=yes "$@"
#|   # TERM=xterm-direct emacs -nw "$@"
#| 
#|   # Non-truecolor (when using rxvt-unicode packge)
#|   # TERM=screen-256color emacs -nw "$@"
#| else
#|   emacs -nw --color=yes "$@"
#|   # TERM=st-direct emacs -nw "$@"
#| fi
#| 
#- }}}


####FILE +x bin/finddupe {{{
#| #!/bin/sh
#| 
#| usage () {
#|     echo -e "Usage: ./finddupe [options...] [directory]"
#|     echo -e "Options:"
#|     echo -e "    -l      list unnecessary files"
#|     echo -e "    -h      print help"
#| }
#| 
#| lflag=0
#| if [ "$1" = -h ]; then usage; exit; fi
#| if [ "$1" = -l ]; then lflag=1; shift; fi
#| 
#| dir=${1:-.}
#| 
#| 
#| # f output lines of the form "<hash>  <file>"
#| # f(){ find "$dir" -type f | while read f; do xxhsum "$f"; done; }
#| # f(){ find "$dir" -type f | while read f; do md5sum "$f"; done; }
#| # f(){ find "$dir" -type f | while read f; do cksum "$f"; done | cut -d' ' -f2 --complement; }
#| f(){ du -ab "$dir"; }
#| 
#| # detect dupes in f's output
#| # $h=hash, $l=prev line, $x=to avoid dup line on >=3 consequtive matches
#| g(){ sort | perl -nae 'BEGIN{$h=-1;$l=""}if($h eq $F[0]){print $l if $x;$x=0;print}else{$x=1}$l=$_;$h=$F[0]'; }
#| 
#| # in output of g, print except first
#| r(){ perl -nae 'BEGIN{$h=-1}if($h eq $F[0]){print}$h=$F[0]'; }
#| 
#| # f | g
#| 
#| # first by size (fast), then hash
#| if [ $lflag -eq 1 ]; then
#|     f | g | cut -f2 | while read f1; do xxhsum "$f1"; done | g | r
#| else
#|     f | g | cut -f2 | while read f1; do xxhsum "$f1"; done | g
#| fi
#- }}}


####FILE +x bin/findimg {{{
#| #!/bin/sh
#| 
#| find . -type f | sed -rn '/(bmp|gif|jpeg|jpg|png|webm)/Ip' | sort
#- }}}


####FILE +x bin/gorun {{{
#| #!/bin/sh
#| 
#| [ $# -eq 0 ] && { echo >&2 "Usage: gorun [-b] file.go"; exit 1; }
#| 
#| if [ "$1" = -b ]; then build=1; shift; else build=; fi
#| f=$1
#| 
#| if [ "$build" ]; then
#|     gofmt -w "$f" && goimports -w "$f" && go build -o "${f%.go}" "$@"
#| else
#|     gofmt -w "$f" && goimports -w "$f" && go run "$@"
#| fi
#- }}}


####FILE +x bin/haropen {{{
#| #!/bin/python
#| 
#| import argparse, base64, json, os, re
#| 
#| # TODO Dump as text
#| 
#| def nonDupeFilename(basename, files):
#|     file = basename
#|     j = 0
#|     while file in files:
#|         j += 1
#|         file = f"{basename}_{j}"
#|     return file
#| 
#| parser = argparse.ArgumentParser()
#| parser.add_argument("-f", "--format", type=str, default="{file}")
#| parser.add_argument("-o", "--outdir", type=str, default="")
#| parser.add_argument("infile")
#| args = parser.parse_args()
#| 
#| infile = args.infile
#| outdir = args.outdir if len(args.outdir) else re.sub(r"[^][_.()a-zA-Z0-9-]", "_", re.sub(r"\.har", "", infile))
#| format = args.format
#| fmtDictExample = {
#|     "index":  True,
#|     "file":   True,
#|     "status": True,
#|     "method": True,
#|     "type":   True,
#|     "time":   True,
#| }
#| 
#| try:
#|     format.format(**fmtDictExample)
#| except:
#|     print("Invalid format:", format)
#|     print("Valid keys are:", ", ".join(list(fmtDictExample.keys())))
#|     print("Example: -f '{index} {file}'")
#|     exit(1)
#| 
#| if os.path.exists(outdir):
#|     if not os.path.isdir(outdir):
#|         exit(1)
#| else:
#|     os.mkdir(outdir)
#| 
#| with open(infile, "rb") as f:
#|     har = json.load(f)
#| 
#| outfiles = {}
#| 
#| for i, e in enumerate(har["log"]["entries"]):
#|     basename = re.sub(r".*/", "", e["request"]["url"]) #TODO format
#|     if len(basename) == 0: basename = "(empty filename)"
#|     # response body
#|     content = e["response"]["content"]
#|     fmtDict = {
#|         "index":  i,
#|         "file":   basename,
#|         "status": e["response"]["status"],
#|         "method": e["request"]["method"],
#|         "type":   "mimeType" in content and content["mimeType"].replace("/", "_"),
#|         "time":   e["time"],
#|     }
#|     outbase = format.format(**fmtDict)[:200]
#|     outfile = nonDupeFilename(outbase, outfiles)
#|     outfiles[outfile] = True
#|     if not "text" in content:
#|         print(f"{i}\t---\t{outfile}")
#|     elif content["text"]:
#|         if content.get("encoding") == "base64":
#|             print(f"{i}\tb64\t{outfile}")
#|             with open(outdir + os.sep + outfile, "wb") as f:
#|                 f.write(base64.b64decode(content["text"]))
#|         else:
#|             print(f"{i}\ttext\t{outfile}")
#|             with open(outdir + os.sep + outfile, "w") as f:
#|                 f.write(content["text"])
#|     else:
#|         print(f"{i}\t---\t{outfile}")
#|     # request body
#|     if "postData" in e["request"]:
#|         postData = e["request"]["postData"]["text"]
#|         with open(outdir + os.sep + outfile + ".req", "w") as f:
#|             f.write(postData)
#| 
#| 
#- }}}


####FILE +x bin/im-ascii {{{
#| #!/bin/sh
#| [ $# -eq 0 ] && { echo "Usage: $0 image"; exit 1; }
#| magick "$1" -geometry "$(($(tput cols) - 1))x" -colorspace Gray -colors 8 txt: | sed -n 's/\([0-9][0-9]*\),\([0-9][0-9]*\).*(\([0-9][0-9]*\).*/\1 \2 \3/p' | awk 'BEGIN{T="#+- "}{if($2%2<=0){if(y!=$2){print "";y=$2}v=($3/100)*length(T);v=v-(v%1);c=substr(T,v+1,1);printf c}}END{print ""}'
#- }}}


####FILE +x bin/im-diff {{{
#| #!/bin/sh
#| [ $# -eq 0 ] && { echo "Usage: $0 image1 image2 [fuzz%] [outfile]"; exit 1; }
#| image1=$1
#| image2=$2
#| fuzz=${3:-10%}
#| out=${4:-NULL:}
#| 
#| wh=$(magick identify -ping -format '%w %h' "$image1")
#| w=${wh% *}
#| h=${wh#* }
#| 
#| ae=$(magick compare -fuzz "$fuzz" -metric AE \
#|     \( -resize "${w}x${h}" "$image1" \) \
#|     \( -resize "${w}x${h}" "$image2" \) \
#|     "$out" 2>&1)
#| 
#| echo "$w,$h,$ae"
#| echo $(( ( 100 * ae ) / ( w * h ) ))
#| 
#- }}}


####FILE +x bin/im-sixel {{{
#| #!/bin/sh
#| [ $# -eq 0 ] && { echo "Usage: $0 image [width]"; exit 1; }
#| magick "$1" -geometry "x${2:-100}" sixel:-
#- }}}


####FILE +x bin/img2txtfull {{{
#| #!/usr/bin/perl
#| 
#| my $img = $ARGV[0];
#| 
#| my $tw = `tput cols`;
#| my $th = `tput lines` - 1;
#| 
#| my ($iw, $ih) = split(" ", `identify -format "%w %h" "$img"`);
#| 
#| # print "$tw,$th,$iw,$ih\n";
#| if ($iw/$ih > $tw/$th) {
#|     system("img2txt -W $tw -g 0.6 $img")
#| } else {
#|     system("img2txt -H $th -g 0.6 $img")
#| }
#- }}}


####FILE +x bin/imgsearch {{{
#| #!/bin/sh
#| 
#| input=$*
#| # echo "[$input]"
#| rclip -f -t 30 "$input" 2>/dev/null | grep -v TensorList | sxiv -t -i -
#- }}}


####FILE +x bin/install-tools {{{
#| #!/bin/sh
#| 
#| if command -v pacman >/dev/null; then
#|     pacman -S tmux vim fish git ranger
#| elif command -v apt >/dev/null; then
#|     apt install tmux vim fish git ranger
#| fi
#- }}}


####FILE +x bin/l {{{
#| #!/bin/sh
#| 
#| # Argument transposer
#| 
#| L_PIPE=${L_PIPE:-"!"}
#| L_ONE=${L_ONE:-"--"}
#| L_MANY=${L_MANY:-"---"}
#| L_DRY=${L_DRY:-}
#| 
#| die(){ echo "ERROR: $*" >&2; exit 1; }
#| 
#| f(){
#|     nph=0  # number of placeholders (both -- and ---, excludes the last --)
#|     nval=0 # number of values after the last --
#|     many=  # is --- used?
#|     for i in "$@"; do
#|         case "$i" in
#|             ("$L_MANY") [ "$many" ] && die "multiple $L_MANY"; many=1; nph=$((nph+1)); nval=0 ;;
#|             ("$L_ONE") nph=$((nph+1)); nval=0 ;;
#|             (*) eval "val_$nval=\$i"; nval=$((nval+1)) ;;
#|         esac
#|     done
#|     nph=$((nph-1))
#|     [ "$nph" -eq 0 ] && die "split given but no placeholder found"
#|     if [ "$nph" -eq -1 ]; then
#|         :
#|     elif [ "$many" ]; then
#|         [ "$nval" -ge "$nph" ] || die "$nval values given for $((nph))+ placeholders"
#|     else
#|         [ "$nval" -eq "$nph" ] || die "$nval values given for $((nph)) placeholders"
#|     fi
#|     # echo "nph=$nph nval=$nval val_0=$val_0 val_1=$val_1 val_2=$val_2 val_3=$val_3" >&2
#| 
#|     cmd=""
#|     idxA=0 # number of non-placeholder args seen so far
#|     idxV=0 # number of values used so far
#|     for i in "$@"; do
#|         case "$i" in
#|             ("$L_PIPE")
#|                 cmd="$cmd| "
#|                 ;;
#|             ("$L_ONE")
#|                 [ "$idxV" -eq "$nval" ] && break # found the last --
#|                 cmd="$cmd\"\$val_$idxV\" "
#|                 idxV=$((idxV+1))
#|                 ;;
#|             ("$L_MANY")
#|                 # note: --- consumes multiple values but still leave as many needed for later --'s
#|                 j=$((nval-nph+1))
#|                 while [ "$j" -gt 0 ]; do
#|                     cmd="$cmd\"\$val_$idxV\" "
#|                     idxV=$((idxV+1))
#|                     j=$((j-1))
#|                 done
#|                 ;;
#|             (*)
#|                 cmd="$cmd\"\$arg_$idxA\" "
#|                 eval "arg_$idxA=\$i"
#|                 idxA=$((idxA+1))
#|                 ;;
#|         esac
#|     done
#| 
#|     if [ "$L_DRY" ]; then
#|         echo "$cmd" >&2
#|         i=0; printf "arg: "; while [ "$i" -lt "$idxA" ]; do eval "printf \"$i=%s \" \"\$arg_$i\""; i=$((i+1)); done; echo
#|         i=0; printf "val: "; while [ "$i" -lt "$idxV" ]; do eval "printf \"$i=%s \" \"\$val_$i\""; i=$((i+1)); done; echo
#|     else
#|         eval "$cmd" # equivalent to e.g. eval '"$arg_0" "$val_0" ..'; shell keywords and special chars are in $arg_0 etc will be interpreted as literal string. also shell variables won't leak
#|     fi
#| }
#| 
#| f "$@"
#| 
#| # echo; date
#| # [ "$(f echo -- b -- a)"             = "a b"         ] || echo fail 1
#| # [ "$(f echo -- b -- -- a c)"        = "a b c"       ] || echo fail 2
#| # [ "$(f echo a -- c --- f -- b d e)" = "a b c d e f" ] || echo fail 3
#| # [ "$(f echo a b c ! rev)"           = "c b a"       ] || echo fail 4
#| # [ "$(f echo a -- c ! rev -- b)"     = "c b a"       ] || echo fail 5
#| # [ "$(f echo a -- b -- c)"           = "a c b"       ] || echo fail 6
#| # [ "$(f echo a -- -- b -- c d)"      = "a c d b"     ] || echo fail 7
#| # [ "$(f echo a --- b -- c d)"        = "a c d b"     ] || echo fail 8
#| # [ "$(f echo a --- d -- -- b c e)"   = "a b c d e"   ] || echo fail 9
#| # [ "$(f echo a -- d -- "b c")"       = "a b c d"     ] || echo fail 10
#| 
#| ##!/bin/bash
#| #
#| ## Argument transposer
#| #
#| #die() { echo "Error: $*" >&2; exit 1; }
#| #
#| #f() {
#| #    local a=()
#| #    local b=()
#| #    local c=()
#| #    # Separate at last --
#| #    # l x1 -- x2 x3 -- x4 x5 ==> a=(x1 -- x2 x3), b=(-- x4 x5)
#| #    for i in "$@"; do
#| #        if [[ "$i" = -- ]]; then
#| #            a+=("${b[@]}")
#| #            b=()
#| #        fi
#| #        b+=("$i")
#| #    done
#| #    # No -- ==> exit
#| #    [[ "${#a[@]}" -eq 0 ]] && die "no -- found"
#| #    # Remove -- from b
#| #    b=("${b[@]:1}")
#| #    # Substitute -- and --- in a
#| #    for i in "${a[@]}"; do
#| #        if [[ "$i" = -- ]]; then
#| #            [[ "${#b[@]}" -eq 0 ]] && die "too few args"
#| #            c+=("${b[0]}")
#| #            b=("${b[@]:1}")
#| #        elif [[ "$i" = --- ]]; then
#| #            [[ "${#b[@]}" -eq 0 ]] && die "too few args"
#| #            c+=("${b[@]}")
#| #            b=()
#| #        else
#| #            c+=("$i")
#| #        fi
#| #    done
#| #    [[ "${#b[@]}" -gt 0 ]] && die "too many args"
#| #    # echo "a=(${a[*]}), b=(${b[*]}), c=(${c[*]})"
#| #    # Run command
#| #    "${c[@]}"
#| #}
#| #
#| ## [[ "$(f echo a -- b -- c)"      == "a c b"   ]] || echo fail
#| ## [[ "$(f echo a -- -- b -- c d)" == "a c d b" ]] || echo fail
#| ## [[ "$(f echo a --- b -- c d)"   == "a c d b" ]] || echo fail
#| #
#| #f "$@"
#- }}}


####FILE +x bin/lft {{{
#| #!/bin/sh
#| 
#| [ "$MYKBD" = colemakdh ] && flag=a || a=""
#| 
#| # shellcheck disable=SC2016
#| lfrc='
#| set mouse
#| set cursorpreviewfmt "" # cursor in preview pane "\033[7;2m"
#| 
#| map s shell-wait
#| map S $$SHELL
#| map x !$f
#| 
#| map H jump-prev
#| map L jump-next
#| 
#| map <enter> open
#| map O &xdg-open $fx
#| 
#| map r
#| map a rename
#| # map I :rename; cmd-home
#| map A :rename; cmd-end
#| map C :rename; cmd-end; cmd-delete-home
#| 
#| map w $tmux -L lf neww $SHELL
#| map S $tmux -L lf neww $SHELL
#| 
#| cmd open ${{
#|     tmux -L lf neww ${VISUAL:-EDITOR} $fx
#| }}
#| 
#| map <c-z> $kill -STOP "$PPID"
#| map <f-7> push &mkdir<space>-p<space>
#| map <f-8> trash
#| 
#| map zt push &touch<space>
#| map zm push &mkdir<space>-p<space>
#| map zd delete
#| 
#| map on :set sortby natural; set info
#| map os :set sortby size; set info size
#| map ot :set sortby time; set info time
#| map oa :set sortby atime; set info atime
#| map oc :set sortby ctime; set info ctime
#| map oe :set sortby ext; set info
#| 
#| # trash command
#| cmd trash %set -f; mv $fx ~/.trash
#| %mkdir -p ~/.trash
#| 
#| # delete command
#| cmd delete ${{
#|     set -f # disable globbing
#|     printf "$fx\n"
#|     printf "delete? [y/n]"
#|     read ans
#|     [ "$ans" = "y" ] && rm -rf $fx
#| }}
#| 
#| # extract the current file with the right command
#| # (xkcd link: https://xkcd.com/1168/)
#| cmd extract ${{
#|     set -f
#|     atool --list --each -- $fx
#|     atool --extract --each -- $fx
#| }}
#| 
#| # compress current file or selected files with tar and gunzip
#| cmd tar ${{
#|     set -f
#|     mkdir $1
#|     cp -r $fx $1
#|     tar czf $1.tar.gz $1
#|     rm -rf $1
#| }}
#| 
#| # compress current file or selected files with zip
#| cmd zip ${{
#|     set -f
#|     mkdir $1
#|     cp -r $fx $1
#|     zip -r $1.zip $1
#|     rm -rf $1
#| }}
#| '
#| 
#| lfrc="
#| $lfrc
#| map $(x=${flag:+k}; echo ${x:-h}) updir
#| map $(x=${flag:+n}; echo ${x:-j}) down
#| map $(x=${flag:+e}; echo ${x:-k}) up
#| map $(x=${flag:+i}; echo ${x:-l}) open
#| map $(x=${flag:+K}; echo ${x:-H}) jump-prev
#| map $(x=${flag:+I}; echo ${x:-L}) jump-next
#| map $(x=${flag:+N}; echo ${x:-J}) half-down
#| map $(x=${flag:+E}; echo ${x:-K}) half-up
#| map $(x=${flag:+j}; echo ${x:-n}) search-next
#| map $(x=${flag:+J}; echo ${x:-N}) search-prev
#| map $(x=${flag:+L}; echo ${x:-I}) :rename; cmd-home
#| "
#| 
#| # shellcheck disable=SC2016
#| tmuxconf='
#| # Shell
#| set -g default-shell /bin/sh
#| set -g default-command "SHELL=$SHELL exec lf -config \"$MYLF_LFRC\"" # without exec, pane_current_command remains $SHELL
#| 
#| # Mouse
#| # set -g mouse on
#| # bind -n WheelDownPane  send Down
#| # bind -n WheelUpPane    send Up
#| # bind -n MouseDown1Pane send right
#| # bind -n MouseUp1Pane   send left
#| 
#| # We expect files are opened from lf in a new tmux window
#| bind    d display -p "#{pane_current_command} #W #I"
#| bind -n T   if "test \"#{pane_current_command}\" = lf" "neww"         "send T"
#| bind -n Q   if "test \"#{pane_current_command}\" = lf" "kill-session" "send Q"
#| bind -n Tab if "test \"#{pane_current_command}\" = lf" "next"         "send Tab"
#| 
#| # Status
#| set -g status-style                 bold,fg=white,bg=black
#| set -g status-position              top
#| set -g status-justify               right
#| set -g status-left                  "[ LF File Manager ]"
#| set -g status-left-length           25
#| set -g status-right                 ""
#| set -g window-status-current-style  fg=black,bg=green
#| set -g window-status-format         " #I#{s/^lf$//:window_name} "
#| set -g window-status-current-format " #I#{s/^lf$//:window_name} "
#| '
#| 
#| export MYLF_LFRC=/tmp/mylfrc
#| echo "$lfrc" > "$MYLF_LFRC"
#| 
#| export MYLF_TMUXCONF=/tmp/mylftmuxconf
#| echo "$tmuxconf" > "$MYLF_TMUXCONF"
#| 
#| exec tmux -L lf -f "$MYLF_TMUXCONF" new
#- }}}


####FILE +x bin/lisp {{{
#| #!/bin/sh
#| 
#| if [ "$TERM" = dumb ] || [ $# -ge 1 ]; then
#|     exec sbcl "$@"
#| else
#|     exec rlwrap -p'3;32' \
#|         --remember \
#|         --history-filename="$HOME/.rlwrap/sbcl_history" \
#|         --histsize=1000000 \
#|         --complete-filenames \
#|         --break-chars "$BREAK_CHARS" \
#|         sbcl
#|         # --file="$HOME/.rlwrap/sbcl_completions" \
#| fi
#| exit
#| 
#| BREAK_CHARS="(){}[],^%$#@\"\";''|\\"
#| RLWRAP=
#| if [ $TERM == "dumb" ]; then  # slime
#|   RLWRAP=
#| else
#|   RLWRAP="rlwrap -p3;32 --remember --history-filename=$HOME/.rlwrap/sbcl_history --histsize=1000000 -c -b $BREAK_CHARS -f $HOME/.rlwrap/sbcl_completions"
#| fi
#| if [ $# -eq 0 ]; then
#|   exec $RLWRAP /usr/bin/sbcl
#| else # permits #!/usr/bin/env sbcl , but breaks sbcl --help, etc.
#|   exec /usr/bin/sbcl --script $*
#| fi
#| 
#- }}}


####FILE +x bin/machineid {{{
#| #!/bin/sh
#| 
#| # Prints machine unique string, truncated to 4 chars.
#| 
#| if [ -e /etc/machine-id ]; then
#|     if cat /etc/machine-id | grep . >/dev/null; then
#|         cat /etc/machine-id | cut -c1-4
#|     else
#|         echo 0000
#|     fi
#| else
#|     echo 0000
#| fi
#- }}}


####FILE +x bin/moshc {{{
#| #!/bin/sh
#| 
#| [ $# -ne 3 ] && { printf "Usage: moshc IP PORT KEY\nPress ctrl-a . to exit\n" >&2; exit 1; }
#| 
#| MOSH_ESCAPE_KEY=$(printf "\x01") MOSH_KEY=$3 mosh-client "$1" "$2"
#- }}}


####FILE +x bin/mypass {{{
#| #!/bin/sh -e
#| 
#| MYPASS_DATADIR=${MYPASS_DATADIR:-~/.config/mypass}
#| 
#| error(){ echo "ERROR: $*" >&2; exit 1; }
#| has(){ command -v "$1" >/dev/null; }
#| hasinit(){ for i in cipher key key.pub list; do [ -e "$MYPASS_DATADIR/$i" ] || return 1; done; }
#| help(){ printf "Usage: %s <e|edit>\n       pass.sh <h|help>\n       pass.sh <i|init>\n       pass.sh <l|list>\n       pass.sh <s|show> NAME\n\nTo generate a key, use \"ssh-keygen -f <path>\" (you should set a passphrase (which is not supported by age-keygen btw))\n\n" "$0"; }
#| 
#| has age || error "age not available"
#| 
#| [ -d "$MYPASS_DATADIR" ] || mkdir -p "$MYPASS_DATADIR"
#| 
#| cd "$MYPASS_DATADIR" || error "the directory $MYPASS_DATADIR does not exist or not accessible. use \"$0 i\" to initialize the database"
#| 
#| case "$1" in
#| 
#|     (e|edit)
#|         hasinit || error "database not initialized"
#|         has nano || has vim || has nvim || error "no suitable editor found (nano/vim/nvim)"
#|         bakdir="backup/$(date +%Y%m%d-%H%M%S)"
#|         mkdir -p "$bakdir"
#|         cp cipher key key.pub "$bakdir/"
#|         tmp=$(mktemp -p /dev/shm/)
#|         trap 'rm -f "$tmp"' INT TERM EXIT
#|         age -i key -d -o "$tmp" cipher || error "decryption failed"
#|         vimcmd="set noswf nobk nowb vi= noudf bdir= pm= nocp | syn on"
#|         # TERM and LANG workaroud (should configure sshd_config AcceptEnv and use SendEnv/SetEnv)
#|         if command -v vim; then
#|             LANG=en_US.UTF-8 vim  -n -u NONE -i NONE --cmd "$vimcmd" "$tmp"
#|         elif command -v nvim; then
#|             LANG=en_US.UTF-8 nvim -n -u NONE -i NONE --cmd "$vimcmd" "$tmp"
#|         elif command -v nano; then
#|             LANG=en_US.UTF-8 TERM=xterm nano -R -C /dev/null "$tmp"
#|         else
#|             error "no suitable editor found"
#|         fi
#|         encok=
#|         for i in 1 2 3; do
#|             echo "Encrypting ..."
#|             if age -i key -e -o cipher "$tmp"; then
#|                 encok=1
#|                 break
#|             fi
#|         done
#|         [ "$encok" ] || error "encryption failed"
#|         awk '/^\[.*\]$/{p=substr($0,2,length($0)-2)}/^%.*=.*/{sub("=.*","");print p"."substr($0,2)}' "$tmp" > list
#|         rm "$tmp"
#|         ;;
#| 
#|     (h|help|"")
#|         help
#|         ;;
#| 
#|     (i|init)
#|         [ -e cipher ] && error "cipher file already exists: $MYPASS_DATADIR/cipher"
#|         [ ! -e key ] && { help; error "please generate a key first at $MYPASS_DATADIR/key"; }
#|         printf "" | age -i key -e -o cipher
#|         printf "" > list
#|         ;;
#| 
#|     (l|list)
#|         hasinit || error "database not initialized"
#|         cat list
#|         ;;
#| 
#|     (s|show)
#|         hasinit || error "database not initialized"
#|         name=$2
#|         [ "$name" ] || { help; error "name not specified"; }
#|         age -i key -d cipher | awk -F= -v name="$name" '/^\[.*\]$/{p=substr($0,2,length($0)-2)}(index($1,"%")==1&&index(p"."substr($1,2),name)){sub("^%[^=]*=","");print;m=1}END{if(!m)exit 1}' || error "could not read database or no matching password"
#|         ;;
#| 
#|     (*)
#|         help; error "bad command: $1"
#|         ;;
#| 
#| esac
#- }}}


####FILE +x bin/myprompt {{{
#| #!/bin/awk -f
#| 
#| # First argument must be "--"
#| 
#| # Performance note:
#| #    cmd | getline x    -- slow
#| #    system(cmd)        -- slow
#| #    getline x < file   -- fast
#| #    ENVIRON["var"]     -- fast
#| # 1. Use external cmd as few times as possible.
#| #    Try to combine multiple cmds.
#| # 2. Try using ENVIRON and only when it does not gives the info, call external cmd.
#| 
#| function print_help() {
#|     print "Usage: myprompt -- [options ...]"
#|     print "Options:"
#|     print "  --shell SHELL     Set shell name           (default: $SHELL)"
#|     print "  --last-status N   Last command exit code   (default: 0)"
#|     print "  --last-signal N   Last command kill signal (default: 0)"
#|     print "  --tmux            Use tmux formatting"
#|     print "  --short           Only print user@host"
#|     print "  --help            Help"
#| }
#| 
#| BEGIN {
#| 
#|     # Parse arguments
#|     argi = 1
#|     SHELL = ENVIRON["SHELL"]
#|     while (argi < ARGC) {
#|         arg = ARGV[argi++]
#|         # printf "arg[%d] = [%s]\n", argi-1, arg
#|         if      (arg == "--shell")               { SHELL      = ARGV[argi++] }
#|         else if (arg == "--last-status")         { LASTSTATUS = ARGV[argi++] }
#|         else if (arg == "--last-signal")         { LASTSIGNAL = ARGV[argi++] }
#|         else if (arg == "--tmux")                { TMUX       = 1            }
#|         else if (arg == "--short")               { SHORT      = 1            }
#|         else if (arg == "--help" || arg == "-h") { print_help(); exit        }
#|         else { printf "Invalid argument: %s\n", arg; print_help(); exit }
#|     }
#| 
#|     # Color table
#|     if (TMUX) {
#|         C[0] = C["k"] = "#[fg=black]"; C[1] = C["r"] = "#[fg=red]"
#|         C[2] = C["g"] = "#[fg=green]"; C[3] = C["y"] = "#[fg=yellow]"
#|         C[4] = C["b"] = "#[fg=blue]";  C[5] = C["m"] = "#[fg=magenta]"
#|         C[6] = C["c"] = "#[fg=cyan]";  C[7] = C["w"] = "#[fg=white]"
#|         C["bold"] = "#[bold]"; C["none"] = "#[default]"
#|     } else {
#|         C[0] = C["k"] = "\033[30m"; C[1] = C["r"] = "\033[31m"
#|         C[2] = C["g"] = "\033[32m"; C[3] = C["y"] = "\033[33m"
#|         C[4] = C["b"] = "\033[34m"; C[5] = C["m"] = "\033[35m"
#|         C[6] = C["c"] = "\033[36m"; C[7] = C["w"] = "\033[37m"
#|         C["bold"] = "\033[1m"; C["none"] = "\033[0m"
#|     }
#| 
#|     # Only print user@host and exit
#|     if (SHORT) {
#|         printf "%s%s", get_uandh(0), C["none"]
#|         exit
#|     }
#| 
#|     # Components
#|     uandh = get_uandh(1)
#|     dir   = get_dir()
#|     git   = get_git()
#|     codes = get_codes()
#|     arrow = get_arrow()
#| 
#|     # Write output
#|     output = uandh C["none"] " " C["m"] (git ? git " " : "") C["g"] dir " " C["r"] (codes ? codes " " : "") C["bold"] arrow " " C["none"]
#|     printf "%s", output # no newline
#| 
#|     # Must explicitly exit, otherwise awk waits stdin
#|     exit
#| 
#| }
#| 
#| function get_uandh(trunc,    user, host, cu, ch) {
#|     user = ENVIRON["USER"]
#| 
#|     # ENVIRON["hostname"], ENVIRON["HOSTNAME"], ENVIRON["HOST"] are not passed to awk from shell? (fish has $hostname, bash $HOSTNAME, zsh $HOST but none of them are passed. sh and elvish has neither of them)
#|     getline host < "/etc/hostname"
#|     if (!host) { "uname -n" | getline host }
#| 
#|     cu = C[hash(user, 7, 6) + 1]
#|     ch = C[hash(host, 7, 0) + 1]
#| 
#|     # abbreviate if too long
#|     if (trunc && length(user) >= 6)
#|         user = substr(user, 1, 2) "." substr(user, (length(user) - 1))
#|     if (trunc && length(host) >= 6)
#|         host = substr(host, 1, 2) "." substr(host, (length(host) - 1))
#| 
#|     # colorize (using hash) and return
#|     return cu user C["c"] "@" ch host
#| }
#| 
#| function get_dir(    pwd, i, a, n) {
#| 
#|     # get pwd
#|     pwd = ENVIRON["PWD"]
#|     if (!pwd) { "pwd" | getline pwd }
#| 
#|     # $HOME to ~
#|     if ((i = index(pwd, ENVIRON["HOME"])) == 1)
#|         pwd = "~" substr(pwd, length(ENVIRON["HOME"]) + 1)
#| 
#|     # remove trailing / (buf not if pwd is the root dir)
#|     if (substr(pwd, length(pwd)) == "/" && length(pwd) > 2)
#|         pwd = substr(pwd, 1, length(pwd) - 1)
#| 
#|     # keep only first char of each path component except the last one
#|     n = split(pwd, a, "/")
#|     for (i=1; i<n; i++)
#|         a[i] = substr(a[i], 1, match(a[i], "[^-._\\[\\]]"))
#| 
#|     # join path components
#|     pwd = a[1]
#|     for (i=2; i<=n; i++)
#|         pwd = pwd "/" a[i]
#|     return pwd
#| 
#| }
#| 
#| function get_git(    cmd, out, out2) {
#|     # checking "command -v git" and "git rev-parse --is-inside-work-tree" does not really increase performance
#|     cmd = "git rev-parse --abbrev-ref HEAD 2>/dev/null && git status -s 2>/dev/null"
#|     cmd | getline out
#|     if (out) {
#|         if (1 == (cmd | getline out2))
#|             out = out "+"
#|         return "(" out ")"
#|     }
#| }
#| 
#| function get_codes(    cmd, killsig) {
#|     if (LASTSTATUS != 0) {
#|         if (LASTSIGNAL != 0) {
#|             cmd = "kill -l " LASTSIGNAL
#|             cmd | getline killsig
#|             # For some reason, following does not work.
#|             #    "kill -l " LASTSIGNAL | getline killsig
#|             # It shows "/bin/sh: 1: 2: not found" when LASTSIGNAL is 2.
#|             killsig = "|SIG" killsig
#|         }
#|         return "[" LASTSTATUS killsig "]"
#|     }
#| }
#| 
#| function get_arrow() {
#|     if (0 != index(SHELL, "fish_private"))
#|         return C["m"] ">>>"
#|     if (0 != index(SHELL, "fish"))
#|         return C["r"] ">" C["y"] ">" (ENVIRON["RANGER_LEVEL"] ? C["g"] : C["b"]) ">"
#|     if (0 != index(SHELL, "elvish"))
#|         return C["g"] ">>" C["w"] ">"
#|     if (0 != index(SHELL, "bash"))
#|         return C["y"] ">>" C["r"] ">"
#|     return C["w"] ">>>"
#| }
#| 
#| function hash(s, n, seed,    i) {
#|     for (i=1; i<=length(s); i++)
#|         seed += ord(substr(s, i, 1))
#|     return seed % n
#| }
#| 
#| function ord(c,    i) {
#|     # perl ord() for printable ascii chars
#|     if (0 != (i = index(" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", c))) {
#|         return i + 31
#|     }
#|     return 0
#| }
#- }}}


####FILE +x bin/mystatus {{{
#| #!/bin/awk -f
#| 
#| # Usage:
#| #     ./mystatus
#| 
#| BEGIN {
#|     DIR_BACKLIGHT = "/sys/class/backlight/intel_backlight/"
#|     DIR_THERMAL   = "/sys/class/thermal/thermal_zone0/"
#|     DIR_POWER     = "/sys/class/power_supply/"
#|     CACHE_STAT    = "/tmp/mystatus_statold"
#| 
#|     o_cpu       = get_cpu()
#|     o_datetime  = get_datetime()
#|     o_backlight = get_backlight()
#|     o_volume    = get_volume()
#|     o_thermal   = get_thermal()
#|     o_power     = get_power()
#|     o_memory    = get_memory()
#| 
#|     printf "%s  B %s%%  V %s  T %sC  C %s  M %s  P %s\n", o_datetime, o_backlight, o_volume, o_thermal, o_cpu, o_memory, o_power
#|     exit
#| }
#| 
#| function get_cpu(    line, ncpu, stat1, stat2, a, b) {
#|     getline stat1 < "/proc/stat"
#|     while ((getline line < "/proc/stat") == 1) {
#|         if (line ~ /^cpu[0-9]+/) {
#|             ncpu++
#|         }
#|     }
#|     getline stat2 < CACHE_STAT
#|     print stat1 > CACHE_STAT
#|     if (split(stat2, b) >= 5 && split(stat1, a) >= 5) {
#|         return int(100 * ((a[2]+a[4])-(b[2]+b[4]))/((a[2]+a[4]+a[5])-(b[2]+b[4]+b[5]))) "%:" ncpu "c"
#|     } else {
#|         return "?"
#|     }
#| }
#| 
#| function get_backlight(    cur, max, val) {
#|     getline cur < (DIR_BACKLIGHT "/brightness") # paren necessary
#|     getline max < (DIR_BACKLIGHT "/max_brightness")
#|     val = log(cur>0?cur:1)/log(max)
#|     val = (val*val*val)*100
#|     return int(val)
#| }
#| 
#| function get_datetime(    val) {
#|     "date +'%Y-%m-%d (%a) %H:%M'" | getline val
#|     return val
#| }
#| 
#| function get_volume(    val) {
#|     if (("pactl get-sink-volume @DEFAULT_SINK@ 2>/dev/null" | getline val) != 1) return "?"
#|     sub("%.*", "", val)
#|     sub(".* ", "", val)
#|     return val "%"
#| }
#| 
#| function get_thermal(    val) {
#|     getline val < (DIR_THERMAL "/temp")
#|     return val / 1000
#| }
#| 
#| function get_power(    capacity, charging) {
#|     if ((getline capacity < (DIR_POWER "/BAT0/capacity")) != 1) return "?";
#|     if ((getline charging < (DIR_POWER "/AC/online")) != 1) return "?";
#|     return capacity "%" (charging ? "+" : "")
#| }
#| 
#| function get_memory(    line, total, avail, used) {
#|     while ((getline line < "/proc/meminfo") == 1) {
#|         if (line ~ /^MemTotal:/) {
#|             total = line
#|         } else if (line ~ /^MemAvailable:/) {
#|             avail = line
#|         }
#|         if (total && avail) {
#|             break
#|         }
#|     }
#|     gsub("[^0-9]*", "", total)
#|     gsub("[^0-9]*", "", avail)
#|     used  = total - avail
#|     # total = int(total / 100000) / 10
#|     # avail = int(avail / 100000) / 10
#|     # used  = int(used  / 100000) / 10
#|     total = int(((total / 100000) + 5) / 10) # round at GB
#|     used  = int(((used  / 100000) + 5) / 10) # round at GB
#|     return used "/" total "GB"
#| }
#- }}}


####FILE +x bin/n {{{
#| #!/bin/bash
#| 
#| command -v nnn >/dev/null || { echo "nnn is not installed" >&2; exit 1; }
#| 
#| # rannnger: emulate ranger in nnn
#| 
#| getPreview() {
#|     local x="$1"
#|     local width="$2"
#|     local height="$3"
#|     if [[ -d "$x" ]]; then
#|         ls -1A --color "$x" | head -n "$((height - 2))" | cut -c 1-"$width"
#|     elif [[ "$(file --mime "$x")" == *charset=binary* ]]; then
#|         echo Binary
#|     else
#|         head -n "$((height - 2))" "$x" | cut -c 1-"$width"
#|     fi
#| }
#| watchPreview() {
#|     declare -A preview=()
#|     declare -A previewTime=()
#|     width=0 height=0
#|     rm "$NNN_FIFO.2" 2>/dev/null || true; mkfifo "$NNN_FIFO.2"
#|     while read -r x; do
#|         echo "$x" >&2 &
#|         mtime=$(stat -c %y "$x")
#|         width1=$(tput cols)
#|         height1=$(tput lines)
#|         if [[ "$width" != "$width1" || "$height" != "$height1" ]]; then
#|             preview=() previewTime=() width="$width1" height="$height1"
#|         fi
#|         if [[ -n "${preview["$x"]}" && "$mtime" = "${previewTime["$x"]}" ]]; then
#|             flag=CACHE
#|         else
#|             flag=NEW
#|             p=$(getPreview "$x" "$width" "$height")
#|             preview["$x"]="$p"
#|             previewTime["$x"]="$mtime"
#|         fi
#|         clear
#|         echo -ne '\e[0m'
#|         echo "$flag ${previewTime["$x"]} $x"
#|         echo "${preview["$x"]}"
#|     done < "$NNN_FIFO" 2> "$NNN_FIFO.2"
#| }
#| watchPreview2() {
#|     # while sleep 1; do date; done
#|     sleep 1
#|     while read -r x; do
#|         x=$(dirname "$x")
#|         x=$(dirname "$x")
#|         clear
#|         ls -1 --color "$x"
#|     done < "$NNN_FIFO.2"
#| }
#| export -f getPreview
#| export -f watchPreview
#| export -f watchPreview2
#| 
#| opener() {
#|     # nano "$2"
#|     tmux -L "$1" new-window nano "$2"
#| }
#| export -f opener
#| 
#| name=aaa-$$
#| fifo="/tmp/fifoaaa-$name"
#| conf="
#| # set -g default-command /bin/sh
#| set -g mouse on
#| set -g pane-border-indicators off
#| set -g pane-active-border-style 'fg=black,bg=black'
#| set -g status off
#| bind -n f6 kill-server
#| bind -n ! new-window -c '#{pane_current_path}'
#| "
#| 
#| rm "$fifo" 2>/dev/null; mkfifo "$fifo"
#| # trap 'tmux -L "$sock" kill-server; exit' INT TERM
#| #
#| export NNN_FIFO="$fifo"
#| export NNN_OPENER='bash -c opener${IFS}"'"$name"'"${IFS}"$1" --'
#| export NNN_FCOLORS=000102030405060708090a0b0c0d0e0f # TODO match ls color + video etc.
#| 
#| tmux -L "$name" -f <(echo "$conf") \
#|     new-session nnn -cdRU \; \
#|     split-window -hb -l 15% bash -c 'watchPreview2' \; \
#|     select-pane -t :.+ \; \
#|     split-window -h  bash -c 'watchPreview' \; \
#|     select-pane -t :.+ \; \
#|     select-pane -t :.+
#| rm "$fifo"
#| 
#- }}}


####FILE +x bin/nf1 {{{
#| #!/bin/sh
#| 
#| # Count number of files is current directory and subdirectories with depth 1
#| 
#| dir=${1:-.}
#| find "$dir" -maxdepth 1 -type d | while read -r d; do n=$(find "$d" | wc -l); printf "%d\t%s\n" "$n" "$d"; done | sort -n
#- }}}


####FILE +x bin/npm-info {{{
#| #!/bin/node
#| 
#| // import * as child_process from "child_process"; // rename to xxx.mjs to use es6 import
#| const child_process = require("child_process");
#| 
#| const CONFIG = { verbose: false }
#| 
#| function run(pkg) {
#|     if (CONFIG.verbose) console.log("npm view --json " + pkg);
#|     const out = child_process.spawnSync("npm", ["view", "--json", pkg]);
#|     const jso = JSON.parse(out.stdout.toString());
#|     return jso;
#| }
#| 
#| function readableSize(size) {
#|     return size < 1024 ? size : `${Math.floor(size/1024)} KiB`;
#| }
#| 
#| function makeCache(pkg) {
#|     const cache = {};
#|     function rec(pkg) {
#|         if (cache[pkg]) return;
#|         const jso = run(pkg);
#|         cache[pkg] = jso;
#|         for (let dep of Object.keys(jso.dependencies || {})) rec(dep);
#|     }
#|     rec(pkg)
#|     const jso1 = cache[pkg];
#|     const size = readableSize(Object.entries(cache).map(x => x[1].dist.unpackedSize).reduce((x, y) => x+y, 0));
#|     const deps = Object.keys(cache).join(" ");
#|     console.log("Name       :", jso1.name);
#|     console.log("Summary    :", jso1.description);
#|     console.log("Version    :", jso1.version);
#|     console.log("Uploaded   :", jso1.time.modified);
#|     console.log("URL        :", jso1.homepage);
#|     console.log("Total Size :", size);
#|     console.log("Total Deps :", deps);
#| }
#| 
#| function main() {
#|     const args = process.argv.slice(2);
#|     let pkg, help;
#|     for (let i=0; i<args.length; i++) {
#|         if (args[i] == "-v") CONFIG.verbose = true;
#|         if (args[i] == "-h" || args[i] == "--help") help = true;
#|         else pkg = args[i];
#|     }
#|     if (help || !pkg) {
#|         console.log("Usage: npm-pkginfo [-h] [-v] PACKAGE");
#|         if (!pkg) console.log("ERROR: package name not given")
#|         return;
#|     }
#|     makeCache(pkg);
#| }
#| 
#| main();
#- }}}


####FILE +x bin/nvimhl {{{
#| #!/bin/sh
#| 
#| if [ $# -ne 1 ]; then
#|     echo "Usage: nvimhl <file>    read file and write syntax-highlighted html"
#|     echo "       nvimhl -         read stdin instead of file"
#|     exit
#| fi
#| 
#| in=$1
#| 
#| cmds='
#| set number
#| set nofoldenable
#| 
#| syntax on
#| colorscheme morning
#| hi Normal ctermfg=black ctermbg=white
#| 
#| let g:html_no_progress=1
#| runtime! syntax/2html.vim
#| w! /dev/stdout
#| qa!
#| '
#| 
#| head='
#| <meta http-equiv="content-type" content="text/html; charset=utf-8">
#| <meta name="viewport" content="width=device-width, initial-scale=1">
#| <style>pre{overflow-wrap:anywhere;line-break:anywhere}.LineNr{user-select:none}</style>
#| '
#| 
#| nvim -u NONE --headless -c "$cmds" "$in" 2>/dev/null \
#|     | awk -v x="$head" '{ print } /<head>/ { print x }'
#| 
#- }}}


####FILE +x bin/passq {{{
#| #!/bin/bash
#| 
#| # All passwords in single plaintext file /all
#| # Each line "%xx.yy=pswd" means passwords ("%" must be at beginning of line)
#| # For convenience, copy into the password into file /auto/xx/yy
#| # on genauto command.
#| # Single file is flexible and easier to remember (than using directories)
#| 
#| function usage {
#|     echo "Usage:"
#|     echo "  passq show <query>  -- Show password that matches <query> in /all"
#|     echo "                         Also copy to clipboard (using xclip)"
#|     echo "  passq edit          -- Edit /all (and run passq genauto)"
#|     echo "  passq list          -- List passwords in /all"
#|     echo "  passq genauto       -- For each password in /all, store it under /auto/ directory"
#|     echo "                         (convenient with rofi pass etc.)"
#|     echo "In /all, each line of the format \"%xx.yy=pswd\" defines a password."
#|     echo "When genauto is used, this password will become /auto/xx/yy with contents pswd."
#| }
#| 
#| [ $# -eq 0 ] && { usage; exit; }
#| 
#| ## Setup parameters
#| op=$1
#| query=$2
#| 
#| ## Get "%name=text" from $1, and add /auto/name with contents text
#| function addauto {
#|     # split from while loop bacause of incorrect vim indentation.
#|     line=$1
#|     name=$(echo "$line" | sed 's/^%\([^=]*\)=\(.*\)/\1/; s/\./\//g')
#|     text=$(echo "$line" | sed 's/^%\([^=]*\)=\(.*\)/\2/')
#|     # echo -e "$name\t$text"
#|     echo -e "$text\n$text" | pass insert --force "auto/$name" >/dev/null
#| }
#| 
#| ## Copy stdin to clipboard (will not output to stdout)
#| has_xclip=$(command -v xclip >/dev/null && echo y || echo n)
#| function clipboard_copy {
#|     if [ "$has_xclip" = y ]; then
#|         xclip -selection clipboard -i
#|     else
#|         cat >/dev/null
#|     fi
#| }
#| 
#| ## genauto (update auto/*)
#| function genauto {
#|     echo "Cleaning /auto/* ..."
#|     pass rm -r --force auto >/dev/null
#|     echo "Generating /auto/* ..."
#|     pass show all | sed "/^%/!d" | while read line; do addauto "$line"; done
#| }
#| 
#| ## Main
#| case "$op" in
#|     show)    pass show all | sed "/^%$query/!d; s/^[^=]*=//" | tee /dev/stderr | clipboard_copy ;;
#|     edit)    pass edit all; genauto ;;
#|     list)    pass show all | sed "/^%/!d" ;;
#|     genauto) genauto ;;
#|     *) echo "Unknown operation: $op" ; usage ;;
#| esac
#| 
#- }}}


####FILE +x bin/ping-scan {{{
#| #!/bin/sh
#| 
#| # vim set noinf
#| 
#| [ $# -eq 0 ] && { echo "Usage: $0 PREFIX [TIMEOUT]"; echo "example: $0 192.168.1 3"; exit 1; }
#| 
#| pfx=${1:-192.168.1}
#| tout=${2:-5}
#| 
#| tmpd=$(mktemp -d /tmp/ping-scan-XXXXXXX)
#| 
#| pids=""
#| for i in $(seq 1 254); do
#|     ip=$pfx.$i
#|     sh -c "timeout $tout ping -c1 $ip && touch \"$tmpd\"/$ip || rm \"$tmpd\"/$ip" >/dev/null 2>&1 &
#|     pids="$pids $!"
#| done
#| wait $pids
#| 
#| ls "$tmpd"
#| rm -r "$tmpd"
#- }}}


####FILE +x bin/pip-info {{{
#| #!/usr/bin/env python3
#| import argparse, json, os, os.path, platform, re, sys, time, urllib.error, urllib.request
#| 
#| CONFIG = { "verbose": False }
#| 
#| # TODO recursive dependencies
#| 
#| def parseSpec(spec):
#|     m = re.match(r"([-.\w]+)(\[([-.\w]+)\])?", spec)
#|     name = m[1]
#|     extra = m[3]
#|     expr = spec.split(";")[1].strip() if ";" in spec else "True" # Empty spec => always required
#|     return { "spec": spec, "name": name, "extra": extra, "expr": expr }
#| 
#| # print(parseSpec("urllib3"))
#| # print(parseSpec("urllib3[secure]"))
#| # print(parseSpec("botocore[crt] (<2.0a0,>=1.21.0) ; extra == 'crt'"))
#| # exit()
#| 
#| dlCacheEnabled = False
#| dlCacheDir     = "__pdp_cache"
#| dlCache        = {}
#| if dlCacheEnabled:
#|     if not os.path.exists(dlCacheDir):
#|         os.mkdir(dlCacheDir)
#|     for f1 in os.listdir(dlCacheDir):
#|         with open(f"{dlCacheDir}/{f1}") as f:
#|             dlCache[f1[:-5]] = json.load(f)
#| def dl(name):
#|     if name in dlCache:
#|         return dlCache[name]
#|     url = f"https://pypi.org/pypi/{name}/json"
#|     req = urllib.request.Request(url)
#|     try:
#|         if CONFIG["verbose"]: print(f"Downloading {url}")
#|         res = urllib.request.urlopen(req)
#|     except urllib.error.HTTPError:
#|         print("No such package:", name, file=sys.stderr)
#|         return {}
#|     dat = res.read().decode("utf-8")
#|     jso = json.loads(dat)
#|     dlCache[name] = jso
#|     if dlCacheEnabled:
#|         with open(f"{dlCacheDir}/{name}.json", "w") as f:
#|             f.write(dat)
#|     return jso
#| 
#| def get_implementation_version():
#|     def format_full_version(info):
#|         version = '{0.major}.{0.minor}.{0.micro}'.format(info)
#|         kind = info.releaselevel
#|         if kind != 'final':
#|             version += kind[0] + str(info.serial)
#|         return version
#| 
#|     if hasattr(sys, 'implementation'):
#|         return format_full_version(sys.implementation.version)
#|     else:
#|         return "0"
#| 
#| def rec(spec):
#|     pkg = parseSpec(spec)
#|     jso = dl(pkg["name"])
#| 
#|     if not jso: return []
#|     # json.dump(jso, open(f"debug-{pkg['name']}.json", "w"), indent=2)
#| 
#|     # See https://peps.python.org/pep-0508/
#|     g = {
#|         "os_name":                        os.name,
#|         "sys_platform":                   sys.platform,
#|         "platform_machine":               platform.machine(),
#|         "platform_python_implementation": platform.python_implementation(),
#|         "platform_release":               platform.release(),
#|         "platform_system":                platform.system(),
#|         "platform_version":               platform.version(),
#|         "python_version":                 '.'.join(platform.python_version_tuple()[:2]),
#|         "python_full_version":            platform.python_version(),
#|         "implementation_name":            sys.implementation.name,
#|         "implementation_version":         get_implementation_version(),
#|         "extra":                          pkg["extra"],
#|     }
#|     depSpecs = jso["info"]["requires_dist"] or []
#|     parsedSpecs = map(parseSpec, depSpecs)
#|     deps = [
#|         parsedSpec for parsedSpec in parsedSpecs
#|         if eval(parsedSpec["expr"], g)
#|     ]
#|     # deps = filter(lambda x: eval(x["expr"], g), map(parseSpec, depSpecs))
#| 
#|     return sum([rec(dep["spec"]) for dep in deps], [pkg["name"]])
#| 
#| def main(args):
#|     CONFIG["verbose"] = args.verbose
#| 
#|     spec = args.pkg
#|     pkg = parseSpec(spec)
#|     dic = dict(dl(pkg["name"]))
#| 
#|     deps = sorted(list(set(rec(spec))))
#|     size = sum([dl(x)["urls"][0]["size"] for x in deps if len(dl(x)["urls"]) > 0])
#| 
#|     dic["info"]["total_deps"] = deps
#|     dic["info"]["total_size"] = size
#| 
#|     sizeTxt = size if size < 1024 else (f"{size//1024} KiB" if size < 1024**2 else f"{size//(1024**2)} MiB")
#| 
#|     if args.json:
#|         json.dump(dic, sys.stdout)
#|     else:
#|         print("Name       :", spec)
#|         print("Summary    :", dic["info"]["summary"])
#|         print("Version    :", dic["info"]["version"])
#|         print("Uploaded   :", dic["releases"][dic["info"]["version"]][0]["upload_time"].replace("T", " "))
#|         print("URL        :", dic["info"]["project_url"])
#|         print("Total Size :", sizeTxt)
#|         print("Total Deps :", " ".join(deps))
#| 
#| if __name__ == "__main__":
#|     ap = argparse.ArgumentParser()
#|     ap.add_argument("-j", "--json", action="store_true")
#|     ap.add_argument("-v", "--verbose", action="store_true")
#|     ap.add_argument("pkg")
#|     args = ap.parse_args()
#|     main(args)
#- }}}


####FILE +x bin/py {{{
#| #!/bin/sh
#| 
#| code="\
#| from (math) import *
#| import (json), (os), (re), (time)
#| import collections as (co); import datetime as (dt); import functools as (ft); import itertools as (it)
#| import urllib.parse as (up); import urllib.request as (ur)"
#| 
#| printf "$(printf %s "$code" | sed 's/(/\\033[31m/g; s/)/\\033[0m/g')\n"
#| 
#| command -v python3 >/dev/null && PYTHON=python3 || PYTHON=python
#| exec "$PYTHON" -ic "$(printf %s "$code" | sed 's/[()]//g')" "$@"
#- }}}


####FILE +x bin/py-jq {{{
#| #!/usr/bin/env python3
#| 
#| # Simple version of jq and gron
#| 
#| import argparse, json, re, sys
#| 
#| def tolist(x):
#|     if type(x) is dict: return list(x.values())
#|     elif type(x) is list: return x
#|     else: raise Exception("err")
#| 
#| def jq(lis, query):
#|     # lis = list(lis); print(lis, query) # generators can be consumed at most once
#|     rkey = r"[^][.]+"
#|     rnum = r"[0-9]+"
#|     if query == "." or query == "": # .
#|         return list(lis)
#|     elif m := re.match(rf"\.({rkey})", query): # .key
#|         return jq((x[m[1]] for x in lis), query[m.end():])
#|     elif m := re.match(rf"\.?\[\]", query): # .[]
#|         return jq(sum((tolist(x) for x in lis), []), query[m.end():])
#|     elif m := re.match(rf"\.?\[({rnum})\]", query): # .[0]
#|         return jq((x[int(m[1])] for x in lis), query[m.end():])
#|     assert False
#| 
#| # should name above "jqm" and create wrapper "jq" which handles multiple inputs
#| 
#| def gron(jso, compact, raw):
#|     result = []
#|     def push(left, right): result.append(f"{left}={right}" if compact else f"{left} = {right};")
#|     def gron(jso, prefix="json"):
#|         if type(jso) is dict:
#|             push(prefix, "{}")
#|             for k, v in jso.items(): gron(v, f"{prefix}.{k}")
#|         elif type(jso) is list:
#|             push(prefix, "[]")
#|             for i, v in enumerate(jso): gron(v, f"{prefix}[{i}]")
#|         else:
#|             push(prefix, jso if raw else json.dumps(jso, separators=(',', ':')))
#|     gron(jso)
#|     return result
#| 
#| def _test():
#|     jso = { "a": { "a1": 10 }, "b": [ 20, "21", 22, "23" ], "c": { "c1": [31, 32], "c2": [33, 34] } }
#|     from subprocess import run
#|     def t1(i, x, y): print(i, x==y, x, "" if x==y else y)
#|     def t2(i, lis, query):
#|         x = jq(lis, query)
#|         y = json.loads(run(["jq", "[" + query + "]"], input="\n".join(json.dumps(x) for x in lis).encode(), capture_output=True).stdout.decode())
#|         t1(i, x, y)
#|     t2(1,  [jso], ".")
#|     t2(2,  [jso], ".a")
#|     t2(3,  [jso], ".b")
#|     t2(4,  [jso], ".[]")
#|     t2(5,  [jso], ".b[]")
#|     t2(6,  [jso], ".c.c2[1]")
#|     t2(7,  [jso], ".c[][1]")
#|     t1(31, gron(jso, False, False), [ 'json = {};', 'json.a = {};', 'json.a.a1 = 10;', 'json.b = [];', 'json.b[0] = 20;', 'json.b[1] = "21";', 'json.b[2] = 22;', 'json.b[3] = "23";', 'json.c = {};', 'json.c.c1 = [];', 'json.c.c1[0] = 31;', 'json.c.c1[1] = 32;', 'json.c.c2 = [];', 'json.c.c2[0] = 33;', 'json.c.c2[1] = 34;' ])
#|     t1(32, gron(jso, True, False), [ 'json={}', 'json.a={}', 'json.a.a1=10', 'json.b=[]', 'json.b[0]=20', 'json.b[1]="21"', 'json.b[2]=22', 'json.b[3]="23"', 'json.c={}', 'json.c.c1=[]', 'json.c.c1[0]=31', 'json.c.c1[1]=32', 'json.c.c2=[]', 'json.c.c2[0]=33', 'json.c.c2[1]=34' ])
#|     t1(33, gron(jso, True, True), [ 'json={}', 'json.a={}', 'json.a.a1=10', 'json.b=[]', 'json.b[0]=20', 'json.b[1]=21', 'json.b[2]=22', 'json.b[3]=23', 'json.c={}', 'json.c.c1=[]', 'json.c.c1[0]=31', 'json.c.c1[1]=32', 'json.c.c2=[]', 'json.c.c2[0]=33', 'json.c.c2[1]=34' ])
#| 
#| if __name__ == "__main__":
#|     ap = argparse.ArgumentParser(description="Simple version of jq and gron")
#|     ap.add_argument("-c", "--compact", action="store_true")
#|     ap.add_argument("-g", "--gron",    action="store_true")
#|     ap.add_argument("-r", "--raw",     action="store_true")
#|     ap.add_argument("--test",          action="store_true")
#|     ap.add_argument("query", nargs="?")
#|     args = ap.parse_args()
#|     if args.test:
#|         _test()
#|     elif args.gron:
#|         lis = gron(json.load(sys.stdin), args.compact, args.raw)
#|         for x in lis:
#|             print(x)
#|     else:
#|         if not args.query:
#|             ap.print_help()
#|             print("ERROR: Query required", file=sys.stderr)
#|             exit(1)
#|         lis = jq([json.load(sys.stdin)], args.query)
#|         for jso in lis:
#|             if args.raw and type(jso) is str:
#|                 print(jso)
#|             elif args.compact:
#|                 print(json.dumps(jso, ensure_ascii=False, separators=(',', ':')))
#|             else:
#|                 print(json.dumps(jso, ensure_ascii=False, indent=2))
#- }}}


####FILE +x bin/q {{{
#| #!/bin/sh
#| 
#| [ $# -le 0 ] && { echo "Usage: ./quiet COMMAND ARGS ..."; exit 1; }
#| 
#| "$@" >/dev/null 2>&1 &
#| 
#| # recommended fish config (complete commands):
#| # complete -c q -xa '(__fish_complete_subcommand)'
#- }}}


####FILE +x bin/quiet {{{
#| #!/bin/sh
#| 
#| [ $# -le 0 ] && { echo "Usage: ./quiet COMMAND ARGS ..."; exit 1; }
#| 
#| "$@" >/dev/null 2>/dev/null
#- }}}


####FILE +x bin/randomstr {{{
#| #!/bin/bash
#| 
#| usage() {
#|     echo "Usage: randomstr [-n] <length> <spec>"
#|     echo "  Get a random string of length <length> using characters specified by <spec>,"
#|     echo "  and copy the string to clipboard using xclip if available."
#|     echo
#|     echo "   -n    don't copy to clipboard"
#|     echo
#|     echo "  <spec> is a string of following characters. (default ad)"
#|     echo "    a/A: small/capital alphabets"
#|     echo "    d:   digits (0-9)"
#|     echo "    w:   shortcut for aAd_"
#|     echo "    _:   underscore"
#|     echo "    -:   some symbols:  !\"#\$%&()*+,-./:;<=>?@[]^_\`{|}~"
#| }
#| 
#| if [ $# -eq 0 ]; then usage; exit 0; fi
#| 
#| nflag=0
#| if [ "$1" = -n ]; then nflag=1; shift; fi
#| 
#| len=$1
#| [ $# -eq 1 ] && options=xad || options=x$2
#| [ "$options" = xw ] && options=xaAd_
#| 
#| charset=""
#| 
#| [ $options != ${options//a/} ] && charset=${charset}a-z
#| [ $options != ${options//A/} ] && charset=${charset}A-Z
#| [ $options != ${options//d/} ] && charset=${charset}0-9
#| [ $options != ${options//_/} ] && charset=${charset}_
#| [ $options != ${options//-/} ] && charset=${charset}'!"#$%&()*+,-./:;<=>?@[\]^_`{|}~'
#| 
#| if [ -z "$charset" ]; then echo "Invalid spec."; usage; exit 0; fi
#| 
#| rnd=$(tr -dc "$charset" </dev/urandom | head -c $len ; echo '')
#| 
#| echo $rnd
#| 
#| if [ $nflag -eq 0 ] && command -v xclip > /dev/null; then
#|     echo -n $rnd | xclip -i -selection clipboard
#| fi
#| 
#| # #!/bin/bash
#| 
#| # # Needs bash for regexp comparison
#| 
#| # if [ $# -ne 1 -a $# -ne 2 ]; then
#| #   echo "Usage: randomstr <length> <spec>"
#| #   echo "  Get a random string of length <length> using characters specified by <spec>,"
#| #   echo "  and copy the string to clipboard using xclip if available."
#| #   echo "  <spec> is a string of following characters. (default ad)"
#| #   echo "    a/A: small/capital alphabets"
#| #   echo "    d:   digits (0-9)"
#| #   echo "    w:   shortcut for aAd_"
#| #   echo "    _/-: underscore and hyphen, literally"
#| #   exit 0
#| # fi
#| 
#| # len=$1
#| # [ $# -eq 1 ] && options=ad || options=$2
#| 
#| # box=()
#| 
#| # [[ $options =~ a || $options =~ w ]] && box+=(a b c d e f g h i j k l m n o p q r s t u v w x y z)
#| # [[ $options =~ A || $options =~ w ]] && box+=(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z)
#| # [[ $options =~ d || $options =~ w ]] && box+=(0 1 2 3 4 5 6 7 8 9)
#| # [[ $options =~ _ || $options =~ w ]] && box+=(_)
#| # [[ $options =~ '-' ]]                && box+=('-')
#| 
#| # i=0
#| # while [ $i -lt $len ]; do
#| #   rnd="$rnd$(shuf -e -n 1 ${box[@]})"
#| #   i=$(expr $i + 1)
#| # done
#| 
#| # echo $rnd
#| 
#| # if command -v xclip > /dev/null; then
#| #   echo -n $rnd | xclip -i -selection clipboard
#| # fi
#- }}}


####FILE +x bin/recentfile {{{
#| #!/bin/sh
#| 
#| # Get the N most recently modified file in the current directory
#| 
#| N="$1"
#| [ -z "$1" ] && N=10
#| 
#| find . -printf "%T+\t%p\n" | sort -r | head -n $N
#- }}}


####FILE +x bin/rsync2 {{{
#| #!/bin/bash
#| 
#| set -euo pipefail
#| 
#| die() { help >&2; echo >&2; echo "ERROR: $*" >&2; exit 1; }
#| echoB() { echo -ne "\033[1m"; echo "$@"; echo -ne "\033[0m"; }
#| 
#| help() {
#|     echo "Usage: $0 FROM TO [RSYNC OPTIONS ...]"
#|     echo "Note: Invoked by moving to FROM and rsync . TO"
#|     echo
#|     echo "* Exclude pattern are interpreted relative to FROM dir"
#|     echo "  - trailing slash   = match directories only"
#|     echo "  - leading slash    = path relative to FROM dir"
#|     echo "  - no leading slash = match any path component (not substring match)"
#|     echo
#|     echo "Examples:"
#|     echo
#|     echo "1. Use --link-dest (incremental backup)"
#|     echo "   rsync2 /path/to/mydir/ /dest/mydir/20230501 --link-dest=/dest/mydir/20230401 -i"
#|     echo
#|     echo "2. Remote dir (rsync:// or -e ssh)"
#|     echo "   rsync2 rsync://server/myentry/ /dest/mydir/0501 --link-dest=/dest/mydir/0401 -i"
#|     echo "   rsync2 user@server:/path/to/mydir/ /dest/mydir/0501 --link-dest=/dest/mydir/0401 -i -e ssh"
#|     echo
#|     echo "TODO allow ssh: as destination"
#| }
#| 
#| logfile="$(pwd)/rsync-$(date +"%Y%m%d-%H%M%S").log"
#| 
#| from=
#| to=
#| # shellcheck disable=SC2054
#| opts=(
#|     -aP # --archive --partial
#|     -H # --hard-links (hard linked two files in source will not be duplicated in the destination)
#|     # -AX # --progress --acls --xattrs
#|     --info=stats2,progress2 -h # --human-readable
#|     --log-file="$logfile.1"
#|     --mkpath # link mkdir -p for TO
#|     --exclude=/.Android/
#|     --exclude=/.cache/
#|     --exclude=/.cargo/
#|     --exclude=/.cpan/
#|     --exclude=/.go/
#|     --exclude=/.ipfs/
#|     --exclude=/.local/share/uv/
#|     --exclude=/.npm/
#|     --exclude=.gradle/
#|     --exclude=.mozilla/firefox/*/storage/
#|     --exclude=.mypy_cache/
#|     --exclude=.thumbnails/
#|     --exclude=.venv/
#|     --exclude=node_modules/
#|     --exclude=site-packages/
#| )
#| 
#| # Parse args
#| [ $# -ge 2 ] || die "Not enough arguments"
#| from=$1
#| to=$2
#| use_ssh=
#| shift 2
#| while [[ $# -ge 1 ]]; do
#|     if [[ "$1" = -e || "$1" = --rsh ]] && [[ $2 =~ ^ssh ]]; then
#|         use_ssh=1
#|     fi
#|     case "$1" in
#|         (*) opts+=("$1"); shift ;;
#|     esac
#| done
#| 
#| is_remote() {
#|     [[ $use_ssh && $1 =~ ^[-a-zA-Z0-9_]+@[-a-zA-Z0-9_]+: ]] || [[ $1 =~ ^rsync:// ]]
#| }
#| 
#| # Normalize and check "from" path
#| [[ "${from%/}" != "$from" ]] || die "$from does not end with /"
#| if ! is_remote "$from"; then
#|     from=$(cd "$from" && pwd)/ # Slash is necessary
#|     [[ -d "$from" ]] || die "$from is not a directory"
#| fi
#| 
#| # Normalize and check "to" path
#| if ! is_remote "$to"; then
#|     if ! [[ -d "$to" ]]; then
#|         mkdir -p "$to" || die "could not create directory $to"
#|     fi
#|     to=$(cd "$to" && pwd)/ # Slash is not necessary
#|     [[ -d "$to" ]] || die "could not create directory $to"
#| fi
#| 
#| # Cd to FROM dir
#| echoB "Cloning:"
#| echo  "  $from"
#| echo  "  as"
#| echo  "  $to"
#| echo
#| 
#| # Construct rsync command
#| cmd=(
#|     rsync
#|     "${opts[@]}"
#|     "$from" "$to"
#| )
#| 
#| # Show command
#| echoB "Command:"
#| for i in "${cmd[@]}"; do
#|     printf "  %q\n" "$i"
#| done
#| 
#| # Run command
#| echo
#| echoB -n "Run this command? [y/n] "; read -r ans
#| [[ "$ans" == y ]] || die "cancelled by user"
#| # echo "${cmd[*]}"
#| # Log deletion to a separate file (rsync does not log deletion to --log-file when --link-dest is used (even with -v)) and merge later
#| grep0(){ grep "$@"; return 0; }
#| if "${cmd[@]}" | tee /dev/stderr | grep0 '^\*deleting' > "$logfile.2"; then s=$?; else s=$?; fi # avoid errexit/pipefail terminating script
#| {
#|     #      2025/10/18 08:55:12 [123456]
#|     sed '/^.......... ........ \[[0-9]*\] Number of files:/Q' "$logfile.1"
#|     echo
#|     echo "===== Deletion log ====="
#|     cat "$logfile.2"
#|     echo "===== Deletion log END ====="
#|     echo
#|     sed -n '/^.......... ........ \[[0-9]*\] Number of files:/,$p' "$logfile.1"
#| } > "$logfile"
#| rm "$logfile.1" "$logfile.2"
#| exit "$s"
#- }}}


####FILE +x bin/running {{{
#| #!/bin/sh
#| 
#| foundprocs=$(ps alx | grep "$1" | grep -v grep | grep -v "$0")
#| [ -n "$foundprocs" ] && exit 0 || exit 1
#| # note: 0=true 1=false
#- }}}


####FILE +x bin/sc1 {{{
#| #!/bin/sh
#| 
#| scimrc=''
#| 
#| [ "$MYKBD" = colemakdh ] && scimrc="$scimrc"'
#| nnoremap "k" "h"
#| nnoremap "n" "j"
#| nnoremap "e" "k"
#| nnoremap "i" "l"
#| nnoremap "a" "e"
#| nnoremap "A" "E"
#| '
#| 
#| tmpdir=$(mktemp -d)
#| mkdir -p "$tmpdir/sc-im"
#| export XDG_CONFIG_HOME="$tmpdir"
#| echo "$scimrc" > "$tmpdir/sc-im/scimrc"
#| sc-im "$@"
#| rm    "$tmpdir/sc-im/scimrc"
#| rmdir "$tmpdir/sc-im/"
#| rmdir "$tmpdir/"
#- }}}


####FILE +x bin/scm {{{
#| #!/bin/bash
#| 
#| # Set NO_RLWRAP to run without rlwrap
#| 
#| libs_small=(
#|     # R7RS small (except scheme.r5rs)
#|     # These are automatically loaded when invoking "gosh -r7" interactively.
#|     base case-lambda char complex cxr eval file inexact lazy load
#|     process-context read repl time write
#| )
#| 
#| libs_srfi=(
#|     # R7RS large
#|     1   # list
#|     114 # comparator (or 128)
#|     125 # hash-table
#|     132 # sort
#|     133 # vector
#|     151 # bitwise
#| 
#|     # Others
#|     2   # and-let*
#|     8   # receive
#|     26  # cut
#|     42  # eager comprehension
#|     152 # string
#|     # 159 or 166 # combinator formatting
#| )
#| 
#| importstr="(import"
#| for l in "${libs_small[@]}"; do importstr+=" (scheme $l)"; done
#| for l in "${libs_srfi[@]}"; do importstr+=" (srfi $l)"; done
#| importstr+=")"
#| 
#| if [ -n "$NO_RLWRAP" ]; then
#|     gosh -fno-read-edit -r7 -e "$importstr" "$@"
#| else
#|     rlwrap -M .scm -q '"' -b "'"'(){}[].,#@;|`"' -pgreen \
#|         gosh -fno-read-edit -r7 -e "$importstr" "$@"
#| fi
#- }}}


####FILE +x bin/termux-my-config {{{
#| #!/bin/sh
#| command -v termux-reload-settings || { echo "termux-reload-settings is not available"; exit 1; }
#| [ -z "$1" ] && color=light || color=dark
#| [ -z "$1" ] && echo "Using light mode. Use 'termux-my-config 1' for dark mode"
#| COLORFILE=~/.termux/colors.properties
#| PROPFILE=~/.termux/termux.properties
#| [ -e "$COLORFILE" ] && { cp "$COLORFILE" "$COLORFILE.$(date +%s)"; }
#| [ -e "$PROPFILE" ] && { cp "$PROPFILE" "$PROPFILE$(date +%s)"; }
#| if [ "$color" = light ]; then
#|     {
#|         echo "foreground=#000"
#|         echo "background=#fff"
#|         echo "cursor=#722"
#|         echo
#|         echo "color0=#e8e6e4"
#|         echo "color1=#ef5253"
#|         echo "color2=#5ca824"
#|         echo "color3=#c49500"
#|         echo "color4=#33b5e1"
#|         echo "color5=#a363d5"
#|         echo "color6=#32ab90"
#|         echo "color7=#18262f"
#|         echo
#|         echo "color8=#b6bfc8"
#|         echo "color9=#ff6263"
#|         echo "color10=#6cb834"
#|         echo "color11=#d4a50c"
#|         echo "color12=#23a5d1"
#|         echo "color13=#b373d5"
#|         echo "color14=#42bba0"
#|         echo "color15=#78868f"
#|     } > "$COLORFILE"
#| else
#|     {
#|         echo "foreground=#D0D0D0"
#|         echo "background=#151515"
#|         echo "cursor=#ffcccc"
#|         echo
#|         echo "color0=#18262f"
#|         echo "color1=#ef5253"
#|         echo "color2=#7cc844"
#|         echo "color3=#e4b51c"
#|         echo "color4=#33b5e1"
#|         echo "color5=#a363d5"
#|         echo "color6=#52cbb0"
#|         echo "color7=#a6afb8"
#|         echo
#|         echo "color8=#78868f"
#|         echo "color9=#ff6263"
#|         echo "color10=#8cd854"
#|         echo "color11=#f4c52c"
#|         echo "color12=#43c5f1"
#|         echo "color13=#b373d5"
#|         echo "color14=#62dbc0"
#|         echo "color15=#b6bfc8"
#|     } > "$COLORFILE"
#| fi
#| {
#|     echo "# vibrate, beep, ignore"
#|     echo "bell-character=ignore"
#|     echo
#|     echo "# back, escape"
#|     echo "back-key=back"
#|     echo
#|     echo "extra-keys = [ \\"
#|     echo " ['ESC', '~', '/',    '|',   '{', '}', 'HOME', 'UP',   'END'  ], \\"
#|     echo " ['TAB', '>', 'CTRL', 'ALT', '[', ']', 'LEFT', 'DOWN', 'RIGHT']  \\"
#|     echo "]"
#| } > "$PROPFILE"
#| termux-reload-settings
#| 
#- }}}


####FILE +x bin/termux-url-opener {{{
#| #!/data/data/com.termux/files/usr/bin/sh
#| 
#| in=$1
#| out=$in
#| out=$(echo "$out" | sed 's/https:..www.google.com.url.q=\([^&]*\).*/\1/')
#| out=$(echo "$out" | sed 's/www.reddit.com/teddit.net/')
#| out=$(echo "$out" | sed 's/old.reddit.com/teddit.net/')
#| out=$(echo "$out" | sed 's/\(mobile.\)*twitter.com/nitter.pussthecat.org/')
#| #[ "$in" = "$out" ] && out='https://en.m.wiktionary.org/w/index.php?search='"$in"
#| echo "IN:  $in"  >> ~/openlog.txt
#| echo "OUT: $out" >> ~/openlog.txt
#| termux-open-url "$out"
#- }}}


####FILE +x bin/tmux_click_move_cursor {{{
#| #!/bin/sh
#| 
#| # configuration:
#| #    bind -n MouseDown3Pane run "path/to/tmux_click_move_cursor '#{mouse_x}' '#{mouse_y}'"
#| 
#| # log(){ echo "$*" >> ~/log; }
#| log(){ :; }
#| 
#| log "$(date)"
#| 
#| tmux select-pane
#| 
#| 
#| cx0=$(tmux display -pF '#{cursor_x}')
#| cy0=$(tmux display -pF '#{cursor_y}')
#| cols=$(tmux display -pF '#{pane_width}')
#| 
#| tx=$1
#| ty=$2
#| 
#| log "$cx0,$cy0,$tx,$ty"
#| log "$cols"
#| 
#| getdir(){
#|     # cx cy tx ty
#|     if [ "$2" -gt "$4" ]; then
#|         echo Left
#|     elif [ "$2" -lt "$4" ]; then
#|         echo Right
#|     elif [ "$1" -gt "$3" ]; then
#|         echo Left
#|     else
#|         echo Right
#|     fi
#| }
#| 
#| getspeed(){
#|     # cx cy tx ty
#|     if [ "$2" -eq "$4" ]; then
#|         if [ "$1" -ge "$3" ]; then
#|             echo $(($1 - $3))
#|         else
#|             echo $(($3 - $1))
#|         fi
#|     elif [ "$2" -lt "$4" ]; then
#|         echo $((cols * ($4 - $2)))
#|     else
#|         echo $((cols * ($2 - $4)))
#|     fi
#| }
#| 
#| getlatency(){
#|     # cx cy
#|     getlatency_t1=$(date +%s.%N)
#|     for _ in $(seq 100); do
#|         sleep 0.1
#|         if [ "$1" -ne "$(tmux display -pF '#{cursor_x}')" ] || [ "$2" -ne "$(tmux display -pF '#{cursor_y}')" ]; then
#|             break
#|         fi
#|     done
#|     getlatency_t2=$(date +%s.%N)
#|     awk -v t1="$getlatency_t1" -v t2="$getlatency_t2" 'BEGIN {print t2-t1}'
#| }
#| 
#| cx=$cx0
#| cy=$cy0
#| 
#| # measure latency
#| # speed=8
#| # go left/right
#| #   if reached goal, exit
#| #   if passed through goal or reached the boundary, switch direction and halve the speed (ensure it decreases by at least one)
#| 
#| speed=$(getspeed "$cx" "$cy" "$tx" "$ty")
#| dir=$(getdir "$cx" "$cy" "$tx" "$ty")
#| latency=.3
#| init=1
#| 
#| for _ in $(seq 20); do
#|     log "$tx $ty $cx $cy $dir $speed"
#|     if [ "$cx" -eq "$tx" ] && [ "$cy" -eq "$ty" ]; then # reached goal
#|         exit
#|     fi
#|     tmux send -N "$speed" "$dir"
#|     sleep $latency
#|     #if [ "$init" ]; then
#|     #    latency=$(getlatency $cx $cy)
#|     #    log "Latency is $latency"
#|     #else
#|     #    sleep $latency
#|     #fi
#|     cx2=$(tmux display -pF '#{cursor_x}')
#|     cy2=$(tmux display -pF '#{cursor_y}')
#|     if [ "$cx" = "$cx2" ] && [ "$cy" = "$cy2" ]; then # boundary
#|         log "Error reached boundary"
#|         exit
#|     fi
#|     dir=$(getdir "$cx2" "$cy2" "$tx" "$ty")
#|     if [ "$cy2" -ne "$ty" ]; then
#|         speed=$((speed / 2))
#|     else
#|         speed2=$(getspeed "$cx2" "$cy2" "$tx" "$ty")
#|         log "speed2: $speed2"
#|         if [ "$speed2" -lt "$speed" ]; then
#|             speed=$speed2
#|         else
#|             speed=$((speed / 2))
#|         fi
#|     fi
#|     if [ "$speed" -eq 0 ]; then
#|         log "Error speed is 0"
#|         exit
#|     fi
#|     cx=$cx2
#|     cy=$cy2
#|     init=
#| done
#| 
#- }}}


####FILE +x bin/tmux_textcomplete.sh {{{
#| #!/usr/bin/env bash
#| 
#| Regexes='[[:alnum:]]{4,}   [-+@._[:alnum:]]{4,}   [-+@._/:[:alnum:]]{4,}'
#| FzfOpts="--no-color --color bw --info hidden"
#| Scrollback=-5
#| PopupWidth=35
#| PopupHeight=8
#| 
#| if [[ $# -eq 0 ]]; then
#| 
#|     # Get info and options (combine to single tmux call for performance)
#|     info=$(tmux display-message -pF 'client_height=#{client_height}:version=#{version}:pane_id=#{pane_id}:pane_left=#{pane_left}:pane_top=#{pane_top}:cursor_x=#{cursor_x}:cursor_y=#{cursor_y}')
#|     tmp=${info#*version=};       version=${tmp%%:*}; version=${version//[^0-9]/}
#|     tmp=${info#*client_height=}; winheight=${tmp%%:*}
#|     tmp=${info#*pane_id=};       curpane=${tmp%%:*}
#|     tmp=${info#*pane_left=};     px=${tmp%%:*}
#|     tmp=${info#*pane_top=};      py=${tmp%%:*}
#|     tmp=${info#*cursor_x=};      cx=${tmp%%:*}
#|     tmp=${info#*cursor_y=};      cy=${tmp%%:*}
#| 
#|     query=$(tmux capture-pane -J -p -S "$cy" -E "$cy")
#|     query=$(echo "${query:0:$cx}" | grep -oE '\w+$' || echo)
#|     # do not use cut for substring, because it counts wide characters etc incorrectly
#| 
#|     if [[ $version -ge 33 ]] && command -v fzf >/dev/null; then
#|         # popup and fzf available
#|         tmux display-popup -EB \
#|             -w "$PopupWidth" -h "$PopupHeight" \
#|             -x $((px + cx - "${#query}" - 2)) -y $((py + cy + 2)) \
#|             -e curpane="$curpane" -e winheight="$winheight" -e query="$query" \
#|             -d "$PWD" "$0 popup"
#|     else
#|         # fallback to menu
#|         curpane="$curpane" winheight="$winheight" query="$query" px="$px" py="$py" cx="$cx" cy="$cy" \
#|             "$0" menu
#|     fi
#| 
#| else
#| 
#|     # Capture contents of all panes
#|     capture_cmd=(tmux)
#|     for pane_id in $(tmux list-panes -a -F '#{pane_id}'); do
#|         capture_cmd+=(capture-pane -J -p -S "$Scrollback" -t "$pane_id" ";")
#|     done
#|     capture=$("${capture_cmd[@]}")
#| 
#|     # Extract words (filter by regex, uniq, then prefix matching)
#|     words=$(for regex in $Regexes; do echo "$capture" | grep -oE "$regex"; done | sort -u | awk -v query="$query" '(substr($0, 1, length(query)) == query) { print }')
#| 
#|     if [[ $1 = popup ]]; then
#|         # Show completion popup with tmux display-popup and fzf
#|         sel=$(echo "$words" | fzf $FzfOpts --prompt "  " --pointer " " --print-query -q "$query")
#|         sel_code=$?
#| 
#|         if [[ "$sel_code" -ne 130 ]]; then
#|             # User selected something
#|             sel=$(echo "$sel" | tail -n1)
#|             input_cmd=(tmux)
#|             [[ "$query" ]] && input_cmd+=(send -t "$curpane" -N "${#query}" BSpace ";")
#|             input_cmd+=(send -t "$curpane" -l "$sel ")
#|             # Simulate key input
#|             "${input_cmd[@]}" 2>/dev/null
#|         fi
#| 
#|     elif [[ $1 = menu ]]; then
#|         # Show completion popup with tmux display-menu
#| 
#|         # Construct menu command
#|         menu_cmd=(tmux display-menu -M -T "Completion" -x $((px + cx - "${#query}" - 2)) -y $((py + cy + 1)))
#|         OLDIFS=$IFS; IFS=$'\n'; i=0; imax=$((winheight - 4))
#|         keys=0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
#|         for word in $words; do
#|             action=""
#|             [[ "$query" ]] && action="send -t '$curpane' -N '${#query}' BSpace ; "
#|             word_esc=${word//"'"/"'\"'\"'"} # escape single quote
#|             action="$action send -t '$curpane' -l '$word_esc '"
#|             menu_cmd+=("$word" "${keys:$i:1}" "$action") # name, key, tmux command to execute (simulate key input)
#| 
#|             i=$((i + 1)); [[ "$i" -ge "$imax" ]] && break
#|         done
#|         IFS=$OLDIFS
#| 
#|         # Show menu
#|         "${menu_cmd[@]}"
#| 
#|     fi
#| 
#| fi
#| 
#| exit
#- }}}


####FILE +x bin/totp.py {{{
#| #!/usr/bin/env python3
#| # https://github.com/DarthJahus/SimpleTOTP
#| 
#| # Jahus
#| # 2018-02-05 23:52
#| #
#| # Documentation:
#| #   https://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm
#| #   HOTP (RFC 4226) https://tools.ietf.org/html/rfc4226
#| #
#| # 2023-11-21: Updated to Python 3, after all these years.
#| #
#| 
#| import time
#| import hmac, hashlib, base64
#| import sys
#| import argparse
#| 
#| 
#| __debug = False
#| 
#| 
#| def int_to_bytestring(i, padding=8):
#| 	"""
#| 	Turns an integer to the OATH specified
#| 	bytestring, which is fed to the HMAC
#| 	along with the secret
#| 	"""
#| 	result = bytearray()
#| 	while i != 0:
#| 		result.append(i & 0xFF)
#| 		i >>= 8
#| 	# It's necessary to convert the final result from bytearray to bytes
#| 	# because the hmac functions in python 2.6 and 3.3 don't work with
#| 	# bytearray
#| 	return bytearray(reversed(result)).rjust(padding, b'\0')
#| 
#| 
#| def key_check(key):
#| 	key = key.replace('-', '').replace(' ', '')
#| 	missing_padding = len(key) % 8
#| 	if missing_padding != 0:
#| 		key += '=' * (8 - missing_padding)
#| 	return base64.b32decode(key, casefold=True)
#| 
#| 
#| def get_key(k, t0=0, ti=30, h_alg=hashlib.sha1, n=6):
#| 	try:
#| 		k = key_check(k)
#| 		digest_size = h_alg().digest_size
#|         # Step 1: Calculate C, number of times TI has elapsed after T0.
#| 		_c = int((time.time()-t0)/ti)
#| 		if __debug: print("C = %i" % _c)
#| 		# Step 2: Compute the HMAC hash H with C as the message and K as the key
#| 		# (the HMAC algorithm is defined in the previous section, but also most cryptographical libraries support it).
#| 		# K should be passed as it is,
#| 		# C should be passed as a raw 64-bit unsigned integer.
#| 		_hmac = hmac.new(key=k, msg=int_to_bytestring(_c), digestmod=h_alg)
#| 		if __debug: print("H = " + _hmac.hexdigest())
#| 		_hmac_digest = int(_hmac.hexdigest(), 16)
#| 		# Step 3:
#| 		# Take the least 4 significant bits of H and use it as an offset, O.
#| 		_mask = (2**(2*2))-1
#| 		_offset = (_hmac_digest >> 0) & _mask
#| 		if __debug: print("O = " + str(_offset))
#| 		# Step 4 :
#| 		# Take 4 bytes from H starting at O bytes MSB,
#| 		# discard the most significant bit and store the rest as an (unsigned) 32-bit integer, I.
#| 		_mask = ((2**(8*4))-1) << ((digest_size - _offset - 4) * 8)
#| 		if __debug: print("_mask = 0x%x" % _mask)
#| 		_i = (_hmac_digest & _mask) >> ((digest_size - _offset - 4) * 8)
#| 		if __debug: print("_res = 0x%x" % _i)
#| 		_mask = 0x7fffffff
#| 		_i = _i & _mask
#| 		if __debug: print("_i = 0x%x\n_i = %i" % (_i,_i))
#| 		# Step 5:
#| 		# The token is the lowest N digits of I in base 10.
#| 		# If the result has fewer digits than N, pad it with zeroes from the left.
#| 		_token = _i % 10**n
#| 		if __debug: print("_token = %i" % _token)
#| 		# Check if n digits are returned
#| 		_token_str = str(_token)
#| 		if len(_token_str) < n:
#| 			_token_str = ('0' * (n - len(_token_str))) + _token_str
#| 		return {"success": True, "result": _token_str}
#| 	except Exception as e:
#| 		return {"success": False, "message": str(e)}
#| 
#| 
#| if __name__ == "__main__":
#| 	_parser = argparse.ArgumentParser(description='Generate a TOTP token.')
#| 	# Define optional arguments
#| 	_parser.add_argument('-i', '--init', type=int, default=0, help='The Unix time to start counting time steps (default: 0)', metavar="INITIAL_TIME")
#| 	_parser.add_argument('-s', '--step', type=int, default=30, help='The time step in seconds (default: 30)', metavar="TIME_STEP")
#| 	_parser.add_argument('-d', '--digits', type=int, default=6, help='The number of digits in the token (default: 6)', metavar="DIGITS")
#| 	_parser.add_argument('-a', '--alg', default='SHA1', choices=['SHA1', 'SHA256', 'SHA512'], help='The hashing algorithm (default: SHA1)', metavar="HASH_ALGORITHM")
#| 	_parser.add_argument('-v', '--verbose', action="store_true", help="Show debug messages")
#| 	# Define the secret key as a positional argument
#| 	_parser.add_argument('key', nargs='*', help='Secret key (spaces and dashes are tolerated)', metavar="KEY")
#| 	
#| 	_args = _parser.parse_args()
#| 	
#| 	# Convert alg to the actual hashlib algorithm
#| 	hash_algorithms = {
#| 		'SHA1': hashlib.sha1,
#| 		'SHA256': hashlib.sha256,
#| 		'SHA512': hashlib.sha512,
#| 	}
#| 	
#| 	__debug = _args.verbose
#| 	
#| 	try:
#| 		_result = get_key(k=''.join(_args.key), t0=_args.init, ti=_args.step, h_alg=hash_algorithms[_args.alg.upper()], n=_args.digits)
#| 		if _result["success"]:
#| 			print(_result["result"])
#| 		else:
#| 			print("Error\n\t%s" % _result["message"])
#| 	except Exception as e:
#| 		print(e)
#| 		print("Incorrect arguments.\nUse:\n\ttotp \"SICRET_KEY\"")
#- }}}


####FILE +x bin/v {{{
#| #!/bin/sh
#| if [ $# -eq 1 ] && [ "${1#!}" != "$1" ]; then
#|     set -- "$(command -v "${1#!}")"
#| fi
#| if command -v vim >/dev/null; then
#|     if [ "$TMUX_ROOT" ]; then
#|         SHELL=sh exec vim -u "$TMUX_ROOT/vimrc" "$@"
#|     else
#|         SHELL=sh exec vim "$@"
#|     fi
#| elif command -v nvim >/dev/null; then
#|     if [ "$TMUX_ROOT" ]; then
#|         SHELL=sh exec nvim -u "$TMUX_ROOT/vimrc" "$@"
#|     else
#|         SHELL=sh exec nvim "$@"
#|     fi
#| elif command -v nano >/dev/null; then
#|     exec nano "$@"
#| elif command -v emacs >/dev/null; then
#|     exec emacs -nw -Q --color=yes "$@"
#| elif command -v vi >/dev/null; then
#|     exec vi "$@"
#| else
#|     echo "No editor found"
#| fi
#- }}}


####FILE +x bin/w3 {{{
#| #!/bin/sh
#| 
#| w3m_dir=$(mktemp -d)
#| mkdir -p "$w3m_dir"
#| 
#| w3m_config='
#| color       1
#| use_history 1
#| save_hist   0
#| no_cache    1
#| '
#| 
#| bookmark_html="$(echo "$MY_W3M_BOOKMARKS" | sed 's/&/\&amp;/g; s/"/\&quot;/g; s/</\&lt;/g; s/>/\&gt;/g; s/ /\&nbsp;/g; s#.*#<li><a href="&">&</a></li>#')"
#| 
#| w3m_bookmark_html='
#| <html>
#|   <head>
#|     <title>Search</title>
#|   </head>
#|   <body>
#|     Search<br><br>
#|     <form method="POST" action="https://lite.duckduckgo.com/lite">
#|       <input type="text"   name="q" size="25">
#|       <input type="submit" value="DuckDuckGo Lite">
#|     </form>
#|     <form method="GET" action="https://www.wikipedia.jp/index.php">
#|       <input type="text"   name="search" size="25">
#|       <input type="submit" value="  Wikipedia    ">
#|     </form>
#|     <form method="GET" action="https://en.wiktionary.org/w/index.php">
#|       <input type="text"   name="search" size="25">
#|       <input type="hidden" name="ns0"    value="1">
#|       <input type="submit" value="  Wiktionary   ">
#|     </form>
#|     <br>Bookmarks<br>
#|     <ul>
#|       <li><a href="http://example.com">Example Domain</a></li>
#|       '"$bookmark_html"'
#|     </ul>
#|   </body>
#| </html>
#| '
#| 
#| case "$MYKBD" in
#|     (colemakdh) key_h=k key_j=n key_k=e key_l=i key_H=K key_J=N key_K=E key_L=I key_n=j key_N=J ;;
#|     (*)         key_h=h key_j=j key_k=k key_l=l key_H=H key_J=J key_K=K key_L=L key_n=n key_N=N ;;
#| esac
#| 
#| 
#| w3m_keymap="
#| keymap DEL    PREV_PAGE
#| keymap $key_J NEXT_PAGE
#| keymap $key_K PREV_PAGE
#| keymap $key_j UP
#| keymap $key_k DOWN
#| keymap $key_h PREV_LINK
#| keymap $key_l NEXT_LINK
#| keymap DOWN   MOVE_DOWN1
#| keymap UP     MOVE_UP1
#| keymap $key_n SEARCH_NEXT
#| keymap $key_N SEARCH_PREV
#| keymap r      RESHAPE
#| keymap u      GOTO
#| keymap U      PEEK_LINK
#| keymap f      SET_OPTION display_link_number=1
#| keymap F      SET_OPTION display_link_number=0
#| keymap ?      HELP
#| keymap [      PREV_PAGE
#| keymap ]      NEXT_PAGE
#| keymap ~      BACK
#| keymap |      GOTO_LINK
#| "
#| 
#| echo "$w3m_config"        > "$w3m_dir/config"
#| echo "$w3m_bookmark_html" > "$w3m_dir/bookmark.html"
#| echo "$w3m_keymap"        > "$w3m_dir/keymap"
#| 
#| export TERM=xterm # needed for mouse in w3m and w3mman
#| export W3M_DIR="$w3m_dir"
#| 
#| if [ -t 0 ]; then
#|     if [ $# -eq 0 ]; then
#|         w3m "$w3m_dir/bookmark.html"
#|     elif [ "$1" = __man__ ]; then
#|         shift
#|         w3mman "$@"
#|     else
#|         w3m "$@"
#|     fi
#| else
#|     w3m "$@"
#| fi
#| 
#| rm -rf "$w3m_dir"
#- }}}


####FILE +x bin/ww {{{
#| #!/bin/bash
#| 
#| shopt -s nullglob
#| 
#| help() {
#|     echo "Usage: ww [option ...] FILE ... -- CMD ..."
#|     echo "       cmd1 | ww [option ...] -- CMD ..."
#|     echo "Watch FILEs and run CMD on change."
#|     echo "In the second form, read paths of FILEs from stdin."
#|     echo "Similar to entr http://eradman.com/entrproject/"
#|     echo
#|     echo "Options:"
#|     echo "   -h         Help"
#|     echo "   -g         Interpret each FILE as bash glob pattern and dynamically update the list of files to watch."
#|     echo "   -t SEC     Check file update on each SEC seconds (default: 1)"
#|     echo "   -z         Exit after cmd exits"
#|     echo "   -R         Disable reloading of persistent child processes"
#|     echo "   -T         Disable showing timestamp when cmd runs"
#| }
#| 
#| 
#| 
#| # Re-expand glob patterns
#| 
#| redo_globs() {
#|     # Accept globs as arguments and store result in the variable "files"
#|     files=()
#|     while [[ $# -ge 1 ]]; do
#|         files+=($1) # this is ok if there is a glob-matching file with spaces
#|         shift
#|     done
#| }
#| 
#| 
#| 
#| ## Parse opts (TODO -- flag (option separator))
#| 
#| [[ $# -eq 0 ]] && { help; exit; }
#| gflag="" Rflag="" tval=1 Tflag="" zflag=""
#| files=()
#| globs=()
#| while true; do
#|     case "$1" in
#|         -h|--help) help; exit;;
#|         -g) gflag=1;   shift;;
#|         -R) Rflag=1;   shift;;
#|         -t) tval="$2"; shift; shift;;
#|         -T) Tflag=1;   shift;;
#|         -z) zflag=1;   shift;;
#|         --) shift; break;;
#|         *) [[ $gflag ]] && globs+=("$1") || files+=("$1"); shift;;
#|     esac
#| done
#| [ ! -t 0 ] && { while read -r f; do files+=("$f"); done; }
#| [[ $# -eq 0 ]] && { echo "ERR: No command" >&2; help; exit 1; }
#| [[ "${#files[@]}" -eq 0 ]] && [[ "${#globs[@]}" -eq 0 ]] && { echo "ERR: No files"   >&2; help; exit 1; }
#| # echo "R=$Rflag,t=$tval,T=$Tflag,z=$zflag"; echo "files: ${files[*]}"; echo "globs: ${globs[*]}"; echo "cmd: $*"
#| # exit
#| 
#| 
#| 
#| ## Misc
#| 
#| timestamp() { echo; date; }
#| 
#| trap ctrl_c INT TERM
#| ctrl_c() {
#|     # ensure kill background process, and exit successfully
#|     [[ -n "$pid" ]] && kill "$pid" 2>/dev/null
#|     exit 0
#| }
#| 
#| 
#| 
#| ## Main program
#| 
#| time=0
#| 
#| while true; do
#| 
#|     # get newest mtime of files
#|     [[ $gflag ]] && redo_globs "${globs[@]}"
#| 
#|     # (skip if glob expands to zero files)
#|     if [[ "${#files[@]}" -ge 1 ]]; then
#| 
#|         newtime=$(stat -c %Y "${files[@]}" | sort -n | tail -n 1)
#| 
#|         if [[ "$time" != "$newtime" ]]; then
#| 
#|             # (unless -R flag) kill persistent process
#|             [[ -z $Rflag ]] && [[ -n "$pid" ]] && { kill "$pid" 2>/dev/null; }
#| 
#|             # (unless -T flag) show timestamp
#|             [[ -z $Tflag ]] && timestamp
#| 
#|             # run command and save pid
#|             "$@" &
#|             pid=$!
#| 
#|             # (-z flag) wait after cmd exits
#|             [[ $zflag ]] && { wait "$pid" && exit 0; }
#| 
#|             # update timestamp data
#|             time=$newtime
#| 
#|         fi
#| 
#|     fi
#| 
#|     sleep "$tval"
#| 
#| done
#| 
#| # ex.
#| # ww -g '*.txt' -- date
#| # # this prints datetime on (1) change in existing .txt file (2) new .txt file added (3) .txt file removed.
#- }}}


####FILE +x bin/x-autorotate {{{
#| #!/bin/sh
#| 
#| # requires iio-sensor-proxy
#| 
#| pkill -x monitor-sensor
#| monitor-sensor --accel | while read -r x; do
#|     t=
#|     case "${x##* }" in
#|         (normal)    t=0   ;;
#|         (right-up)  t=90  ;;
#|         (bottom-up) t=180 ;;
#|         (left-up)   t=270 ;;
#|     esac
#|     [ -n "$t" ] && swaymsg output DSI-1 transform "$t"
#| done
#- }}}


####FILE +x bin/x-brightness {{{
#| #!/bin/sh
#| 
#| for dir in /sys/class/backlight/backlight /sys/class/backlight/intel_backlight; do
#|     [ -d "$dir" ] && break
#| done
#| brightness_file=$dir/brightness
#| max_brightness_file=$dir/max_brightness
#| 
#| as_root() { if command -v sudo >/dev/null; then sudo "$@"; elif command -v doas >/dev/null; then doas "$@"; else echo 'need sudo or doas' >&2; fi }
#| 
#| help() {
#|     echo "Usage: $0 <brightness>" >&2
#|     echo "<brightness> = 1, +2, -2 etc. Max $(cat $max_brightness_file)" >&2
#|     echo 'You should add the following line to the very end of /etc/sudoers (via "sudo visudo")' >&2
#|     echo "  ALL ALL=(ALL) NOPASSWD: /usr/bin/tee $brightness_file" >&2
#|     echo "Or doas.conf:" >&2
#|     echo "  permit nopass :wheel cmd /usr/bin/tee args $brightness_file" >&2
#| }
#| [ $# -eq 0 ] && { help; exit 1; }
#| v=$1
#| # Check $v is number
#| [ 0 = $(expr "x$v" : '^x[-+]\?[0-9]*%*$') ] && { echo "Not a number: $v" >&2; help; exit 1; }
#| # Calc new value
#| read -r max < "$max_brightness_file"
#| case "$v" in
#|     (+*%) v=+$(( max * ${v%%%} / 100 )) ;; # +<n>%
#|     (*%)  v=$(( max * ${v%%%} / 100 )) ;; # -<n>% or <n>%
#| esac
#| case "$v" in
#|     (-*) read -r c < "$brightness_file"; b=$(( c - ${v#-} ));;
#|     (+*) read -r c < "$brightness_file"; b=$(( c + ${v#+} ));;
#|     (*)  b=$v;;
#| esac
#| # Value range check
#| [ "$b" -lt 1 ] && b=1
#| [ "$b" -gt "$max" ] && b=$max
#| echo "v=$v, c=$c, b=$b, max=$max"
#| # Write value
#| echo "$b" | as_root /usr/bin/tee "$brightness_file" >/dev/null
#| 
#| # note sudo's NOPASSWD won't work if there is a duplicate slash
#| # note sudo's NOPASSWD must be in the last line
#- }}}


####FILE +x bin/x-gestures {{{
#| #!/bin/sh
#| pkill -x lisgd
#| lisgd -d /dev/input/event1 \
#|     -g '1,LR,T,*,R,pkill -x -SIGUSR2 wvkbd-mobintl' \
#|     -g '1,RL,T,*,R,pkill -x -SIGUSR1 wvkbd-mobintl' \
#|     -g '1,UD,R,*,P,~/bin/x-brightness -10' \
#|     -g '1,DU,R,*,P,~/bin/x-brightness +10' \
#|     -g '2,UD,T,M,R,swaymsg kill' \
#|     -g '1,UD,T,*,R,~/bin/x-run'
#- }}}


####FILE +x bin/x-hibernate {{{
#| #!/bin/sh
#| 
#| swaylock -c 888888 & sleep .1 && systemctl hibernate
#- }}}


####FILE +x bin/x-mute {{{
#| #!/bin/sh
#| # Usage: ./mute
#| pactl set-sink-mute @DEFAULT_SINK@ toggle
#- }}}


####FILE +x bin/x-picom {{{
#| #!/bin/bash
#| 
#| # To detach:
#| #   ./x-picom -b
#| 
#| pkill --exact picom
#| 
#| picom_args=(
#|     --config /dev/null         # no default config
#|     --no-fading-destroyed-argb # prevent urxvt window from flashing on closing
#|     --no-fading-openclose      # not working? use .config/compton.conf
#|     --xrender-sync-fence       # Avoid "keyboard/mouse lag"; actually the display is not redrawing
#|     --backend xrender          # "xrender" is less laggy than "glx"?
#|     --vsync                    # Avoid tearing
#|     -I1 -O1                    # No fading (workaround)
#| 
#|     # no shadow for maximized windows, unfocused windows and menu
#|     # --shadow-exclude "(widthb > $wsmall || heightb > $hsmall) || !focused" # || (WM_WINDOW_ROLE@:s *= "fluxbox-menu")'
#|     --shadow-exclude "!(window_type *= \"menu\") && (focused || !focused)"
#| )
#| 
#| exec picom "${picom_args[@]}" "$@"
#- }}}


####FILE +x bin/x-run {{{
#| #!/bin/sh
#| 
#| b="#000000dd"
#| f="#00bbdd"
#| hb="#333333"
#| # pkill -x -SIGUSR2 wvkbd-mobintl
#| # bemenu-run -i -l20 --scrollbar auto --counter always -W.3 --nb $b --ab $b --tf $f --hf $f --fbf $f --fbb $hb --hb $hb --fn "Noto Sans Mono 10"
#| cd "$(dirname "$0")"/rundir
#| cmd=$(find . -maxdepth 1 -not -type d | sed 's#^..##' | LC_ALL=C sort | bemenu -i -l20 -p ">" --scrollbar auto -W.33 --nb $b --ab $b --tf $f --hf $f --fbf "#ff3333" --fbb $hb --hb $hb --fn "Noto Sans Mono 33")
#| cwd=$(pwd)
#| cd ~
#| case "$cmd" in
#|     (*@) sh -c "${cmd%@}" ;;
#|     ("") : ;;
#|     (*) sh -c "$cwd/$cmd" & ;;
#| esac
#| # pkill -x -SIGUSR1 wvkbd-mobintl
#- }}}


####FILE +x bin/x-status {{{
#| #!/bin/sh
#| 
#| read bat < /sys/class/power_supply/rk817-battery/capacity
#| read sta < /sys/class/power_supply/rk817-battery/status
#| case "$sta" in
#|     (Charging)         sta=+ ;;
#|     (Full|Discharging) sta=  ;;
#|     (*)                sta=? ;;
#| esac
#| 
#| vol=$(pactl get-sink-volume @DEFAULT_SINK@)
#| vol=${vol% / *}; vol=${vol##* }
#| 
#| read br  < /sys/class/backlight/backlight/brightness
#| read brm < /sys/class/backlight/backlight/max_brightness
#| br=$((100 * br / brm))
#| 
#| dt=$(date +'%Y-%m-%d (%a) %H:%M:%S')
#| 
#| #net=$(echo $(ip a | sed -n '/state UP/s/^[^ ]* \([^ :]*\).*/\1/p'))
#| net=$(echo $(ip -o a | awk '(!/ lo /)&&(!/ inet6 /){if(!a[$2]++){print $2}sub("/.*","",$4);print $4}'))
#| #net=${net:--}
#| 
#| printf '%s  %s :%s *%s  %s\n' "$net" "[$sta$bat%]" "$vol" "$br%" "$dt"
#- }}}


####FILE +x bin/x-term {{{
#| #!/bin/sh
#| 
#| font="Noto Sans Mono:size=10.5"
#| footclient -o font="$font" -e tmux
#- }}}


####FILE +x bin/x-volume {{{
#| #!/bin/sh
#| L(){ echo "$*"; "$@"; }
#| # L(){ echo "$*"; }
#| case "$1" in
#|     ("")
#|         echo "Usage: $0 <volume>     (<volume> = 20%, +5%, -10% etc.)"
#|         echo "Usage: $0 sink <sink>  (change sink; useful for eq settings)"
#|         exit 1
#|         ;;
#|     (sink)
#|         sink=$2
#|         vol=$(pactl get-sink-volume @DEFAULT_SINK@ | sed -n 's/.* \([0-9][0-9]*%\).*/\1/p')
#|         # change volume of this sink to current value
#|         L pactl set-sink-volume "$sink" "$vol"
#|         # change default sink
#|         L pactl set-default-sink "$sink"
#|         # change sink for existing programs
#|         for id in $(pactl list short sink-inputs | cut -f1); do
#|             L pactl move-sink-input "$id" "$sink"
#|         done
#|         # change volume of other sinks to 100%
#|         for sink2 in $(pactl list short sinks | cut -f1); do
#|             if [ "$sink2" != "$sink" ]; then
#|                 L pactl set-sink-volume "$sink2" 100%
#|             fi
#|         done
#|         ;;
#|     (*)
#|         pactl set-sink-volume @DEFAULT_SINK@ "$1" ;;
#| esac
#| # [ $# -eq 0 ] && { echo "Usage: $0 <volume> (<volume> = 20%, +5%, -10% etc.)"; exit 1; }
#- }}}


####FILE +x bin/xcopy {{{
#| #!/bin/sh
#| 
#| text=$*
#| 
#| wsl_copy() {
#|     # win32yank -i; return
#|     cd /
#| 
#|     magic=ac7i6ma0
#|     tmpdir=/tmp/wslclip
#|     [ ! -d "$tmpdir" ] && mkdir -p "$tmpdir"
#|     pidfile="$tmpdir/copy_pid"
#|     inputfile="$tmpdir/copy_input"
#|     oninitfile="$tmpdir/copy_oninit"
#|     logfile="$tmpdir/copy_log"
#|     log() { printf "%s (sh) %s\n" "$(date +'%Y/%m/%d %H:%M:%S.%3N')" "$*" >> "$logfile"; }
#|     printf "%s\n" "------" >> "$logfile"
#| 
#|     # if "pidfile cannot be read" or "pid written in pidfile no longer exists", start new daemon
#|     if ! read -r pid < "$pidfile" 2>/dev/null || [ ! -e "/proc/$pid/fd/0" ]; then
#|         log "pid=[$pid], $([ -z "$pid" ] && printf "%s" "read $pidfile failed"), $([ -n "$pid" ] && [ ! -e "/proc/$pid/fd/0" ] && printf "%s" "/proc/$pid/fd/0 does not exist")"
#| 
#|         # shellcheck disable=SC2016
#|         pwsh='
#|         # '$magic' wsl-xcopy-pwsh # For pgrep purpose
#|         $wslroot="//wsl$/'"$WSL_DISTRO_NAME"'"
#|         echo a > "$wslroot/'"$oninitfile"'"
#|         function log{ param($msg); $d=$(get-date -Format "yyyy/MM/dd HH:mm:ss.fff"); echo "$d (PS) $msg" >> "$wslroot/'"$logfile"'"}
#|         log init
#|         while(1){
#|             $got = Read-Host
#|             log "read-host done"
#| 
#|             # Assumes base64 encoded UTF-8 data is in $inputfile
#|             #$b64 = Get-Content "$wslroot/'"$inputfile"'"
#|             #$bin = [System.Convert]::FromBase64String($b64)
#|             #$str = [System.Text.Encoding]::UTF8.GetString($bin)
#|             #Set-Clipboard $str
#|             # echo "b64=$b64,str=$str"
#| 
#|             $str = (Get-Content -Raw -Encoding utf8 "$wslroot/'"$inputfile"'")
#|             log "get-content done, str is [$str]"
#|             Set-Clipboard $str
#|             log "set-clipboard done"
#| 
#|         }
#|         '
#| 
#|         mkdir -p "$tmpdir"
#|         touch "$inputfile"
#|         rm "$oninitfile" 2>/dev/null
#| 
#|         # Run powershell and save pid
#|         # This reads $inputfile and save it to clipboard whenever something is written in stdin.
#|         # An alternative is clip.exe, but has encoding problem, not works on some directories, slower than this background-powershell method etc.
#|         # A dummy process is piped to powershell.exe, otherwise we cannot write to its stdin with /proc/$pid/fd/0.
#|         # Also powershell.exe must be piped to something other than stdout, otherwise it does not persist when not launched from terminal (e.g. from vim).
#|         # Replacing "while ..." with "cat" works in terminal, but not in script (infinite loop)
#|         log "starting powershell"
#|         while true; do sleep 100000; done | powershell.exe "$pwsh" > /dev/null &
#|         pid=$!
#|         echo $pid > "$pidfile"
#|         log "PID $pid is written to $pidfile"
#| 
#|         # wait until $oninitfile is created (powershell startup is slow)
#|         # i=0; while [ $((i += 1)) -lt 5000 ] && [ ! -e "$oninitfile" ]; do sleep .01; done
#|         i=0; while [ $((i += 1)) -lt 5000 ] && [ ! -e "$oninitfile" ]; do sleep 0; done
#|         log "$oninitfile created."
#| 
#|     fi
#| 
#|     # { [ -z "$text" ] && cat || printf "%s" "$text"; } | base64 > "$inputfile"
#|     # echo > "/proc/$pid/fd/0"
#|     log "writing to $inputfile"
#|     { [ -z "$text" ] && cat || printf "%s" "$text"; } > "$inputfile"
#|     log "writing to /proc/$pid/fd/0"
#|     echo > "/proc/$pid/fd/0"
#| 
#| }
#| 
#| 
#| ## Main program
#| 
#| if [ -n "${IS_WSL}${WSL_DISTRO_NAME}${WSL_INTEROP}${WSL_ENV}" ]; then # wsl
#|     wsl_copy
#| 
#| elif [ -n "${WAYLAND_DISPLAY}" ]; then # wayland
#|     { [ -z "$text" ] && cat || printf "%s" "$text"; } \
#|         | wl-copy
#|     wl-paste 2>/dev/null | xclip -selection clipboard -i 2>/dev/null &
#|     # note: wl-clipboard-rs is faster than wl-clipboard
#|     # (`time echo a | wl-copy` is 10ms vs 35ms)
#|     # but wl-clipboard-rs does not work on gnome as of early 2024
#| 
#| elif command -v xclip > /dev/null; then # xorg
#|     { [ -z "$text" ] && cat || printf "%s" "$text"; } \
#|         | xclip -selection clipboard -i
#| 
#| elif [ "$PREFIX" != "${PREFIX#*/com.termux/*}" ]; then # termux
#|     { [ -z "$text" ] && cat || printf "%s" "$text"; } \
#|         | termux-clipboard-set
#| 
#| fi
#- }}}


####FILE +x bin/xpaste {{{
#| #!/bin/sh
#| 
#| wsl_paste() {
#|     # win32yank -o; return
#|     cd /
#| 
#|     magic=pklgds25
#|     tmpdir=/tmp/wslclip
#|     [ ! -d "$tmpdir" ] && mkdir -p "$tmpdir"
#|     pidfile="$tmpdir/paste_pid"
#|     outputfile="$tmpdir/paste_output"
#|     readyfile="$tmpdir/paste_ready"
#|     logfile="$tmpdir/paste_log"
#|     log() { printf "%s (sh) %s\n" "$(date +'%Y/%m/%d %H:%M:%S.%3N')" "$*" >> "$logfile"; }
#|     printf "%s\n" "------" >> "$logfile"
#| 
#|     # if "pidfile cannot be read" or "pid written in pidfile no longer exists", start new daemon
#|     if ! read -r pid < "$pidfile" 2>/dev/null || [ ! -e "/proc/$pid/fd/0" ]; then
#|         log "pid=[$pid], $([ -z "$pid" ] && printf "%s" "read $pidfile failed"), $([ -n "$pid" ] && [ ! -e "/proc/$pid/fd/0" ] && printf "%s" "/proc/$pid/fd/0 does not exist")"
#| 
#|         # shellcheck disable=SC2016
#|         pwsh='
#|         # '$magic' wsl-xpaste-pwsh # For pgrep purpose
#|         $wslroot="//wsl$/'"$WSL_DISTRO_NAME"'"
#|         function log{ param($msg); $d=$(get-date -Format "yyyy/MM/dd HH:mm:ss.fff"); echo "$d (PS) $msg" >> "$wslroot/'"$logfile"'"}
#|         log "init"
#|         while(1){
#|             $got = Read-Host
#|             log "read-host done"
#| 
#|             # Encode string as utf8 and then convert to base64
#|             #$str = Get-Clipboard -Raw # without -Raw we get an array of strings
#|             #$bin = ([System.Text.Encoding]::UTF8).GetBytes($str)
#|             #$b64 = [Convert]::ToBase64String($bin)
#|             #echo $b64 > "$wslroot/'"$outputfile"'"
#|             #echo a > "$wslroot/'"$readyfile"'"
#| 
#|             $a = (gcb -Raw).Replace("`r`n", "`n")                   # CRLF to LF
#|             log "a is [$a]"
#|             [IO.File]::WriteAllText("$wslroot/'"$outputfile"'", $a) # no trailing CRLF
#|             log "written to '"$outputfile"'"
#|             echo a > "$wslroot/'"$readyfile"'"
#|             log "written to '"$readyfile"'"
#| 
#|             # "Get-Clipboard -Raw > file" has an encoding problem (which can be fixed with out-file -encoding utf8), and it also adds some garbage leading/trailing bytes
#|             # $str = Get-Clipboard
#|         }
#|         '
#| 
#|         mkdir -p "$tmpdir"
#| 
#|         # Run powershell and save pid
#|         # This writes clipboard content to $outputfile whenever something is written in stdin.
#|         # Simple "powershell.exe Get-Clipboard" works, but very slow
#|         # A dummy process is piped to powershell.exe, otherwise we cannot write to its stdin with /proc/$pid/fd/0.
#|         # Also powershell.exe must be piped to something other than stdout, otherwise it does not persist when not launched from terminal (e.g. from vim).
#|         # Replacing "while ..." with "cat" works in terminal, but not in script (infinite loop)
#|         log "starting powershell"
#|         while true; do sleep 100000; done | powershell.exe "$pwsh" >/dev/null &
#|         pid=$!
#|         echo $pid > "$pidfile"
#|         log "PID $pid is written to $pidfile"
#| 
#|     fi
#| 
#| 
#|     log "removing $outputfile and $readyfile"
#|     rm "$outputfile" "$readyfile" 2>/dev/null
#|     log "writing to /proc/$pid/fd/0"
#|     echo > "/proc/$pid/fd/0"
#|     # i=0; while [ $((i += 1)) -lt 5000 ] && [ ! -e "$readyfile" ]; do sleep .001; done
#|     i=0; while [ $((i += 1)) -lt 5000 ] && [ ! -e "$readyfile" ]; do sleep 0; done
#|     # first tr removes non-base64 characters, second tr fixes CRLF
#|     #cat "$outputfile" | tr -c -d "[:alnum:][+/=]" | base64 -d | tr -d ''
#|     log "$readyfile found, now cat'ing it"
#|     cat "$outputfile"
#| 
#| }
#| 
#| 
#| ## Main program
#| 
#| if [ -n "${IS_WSL}${WSL_DISTRO_NAME}${WSL_INTEROP}${WSL_ENV}" ]; then # wsl
#|     wsl_paste
#| 
#| elif [ -n "${WAYLAND_DISPLAY}" ]; then # wayland
#|     wl-paste -n # must wall wl-copy WITHOUT -n, and wl-paste WITH -n
#| 
#| elif command -v xclip > /dev/null; then # xorg
#|     xclip -selection clipboard -o
#| 
#| elif [ "$PREFIX" != "${PREFIX#*/com.termux/*}" ]; then # termux
#|     termux-clipboard-get
#| 
#| fi
#- }}}


